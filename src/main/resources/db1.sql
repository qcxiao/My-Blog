-- MySQL dump 10.13  Distrib 5.7.19, for macos10.12 (x86_64)
--
-- Host: www.qcxiao.top    Database: tale
-- ------------------------------------------------------
-- Server version	5.7.20

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `tale`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `tale` /*!40100 DEFAULT CHARACTER SET latin1 */;

USE `tale`;

--
-- Table structure for table `t_attach`
--

DROP TABLE IF EXISTS `t_attach`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_attach` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `fname` varchar(100) NOT NULL DEFAULT '',
  `ftype` varchar(50) DEFAULT '',
  `fkey` varchar(100) NOT NULL DEFAULT '',
  `author_id` int(10) DEFAULT NULL,
  `created` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_attach`
--

LOCK TABLES `t_attach` WRITE;
/*!40000 ALTER TABLE `t_attach` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_attach` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comments`
--

DROP TABLE IF EXISTS `t_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `author_id` int(10) unsigned DEFAULT '0',
  `owner_id` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `content` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comments`
--

LOCK TABLES `t_comments` WRITE;
/*!40000 ALTER TABLE `t_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_contents`
--

DROP TABLE IF EXISTS `t_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `content` text COMMENT '内容文字',
  `author_id` int(10) unsigned DEFAULT '0',
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `tags` varchar(200) DEFAULT NULL,
  `categories` varchar(200) DEFAULT NULL,
  `hits` int(10) unsigned DEFAULT '0',
  `comments_num` int(10) unsigned DEFAULT '0',
  `allow_comment` tinyint(1) DEFAULT '1',
  `allow_ping` tinyint(1) DEFAULT '1',
  `allow_feed` tinyint(1) DEFAULT '1',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_contents`
--

LOCK TABLES `t_contents` WRITE;
/*!40000 ALTER TABLE `t_contents` DISABLE KEYS */;
INSERT INTO `t_contents` VALUES (1,'关于我','about',1487853610,1515257416,'### 建站的初衷\r\n用于技术学习的心得记录\r\n### 自我描述\r\n估计要把此生浪费在永无止境的编程技术上了，哈哈。\r\n一直想把自己的一些学习心得记录下来，由于大多博客网站的页面不清爽且不能为所欲为，想着自己构建一个自己的网站确不想一直是个行动的矮子，直到看到My-blog发现很喜欢，因此打算用来个人使用，在此赞其开源精神。同时，我希望通过维护个人网站，还可以将自己所了解的知识体系串联起来。\r\n### 网站地址\r\nhttp://47.104.143.202\r\n### 我的邮箱\r\n280887262@qq.com',1,'page','publish',NULL,NULL,64,0,1,1,1),(4,'第一章 进入Java多线程领域',NULL,1515257616,1515484390,'## 本章目标\r\n* 线程的概念\r\n* 实现多线程的方式\r\n* 线程的状态\r\n* 线程的启动\r\n* 线程的暂停\r\n* 线程的停止\r\n* 线程的优先级\r\n* 线程安全相关问题\r\n## 概念\r\n* 线程：程序中单独顺序的控制流；线程本身依靠程序进行运行，线程是程序中的顺序控制流，只能使用分配给程序的资源和环境\r\n* 进程：正在执行的程序\r\n## 实现多线程的方式\r\n* 继承Thread类，并复写run()方法通过start()方法启动程序\r\n* 实现Runnable接口\r\n\r\n## 线程的状态\r\n创建、就绪、运行、阻塞、终止\r\n\r\n## 线程常用方法\r\n* 取得线程对象\r\n`Thread.currentThread()`\r\n* 获取线程名称\r\n`Thread.currentThread().getName()`\r\n* 判断线程是否启动\r\n`new Thread(r1).isAlive();`\r\n* 线程的强行运行\r\njoin()\r\n* 线程的休眠\r\nsleep()\r\n* 线程的礼让\r\nyield()\r\n\r\n## 线程的启动\r\n线程启动是调用了Thread类的start()方法，表示此时此线程已经准备就绪等待CPU的调用，使线程拥有运行的机会；此过程是让CPU安排一个时间来调用Thread类中的run()方法，使线程得以运行，启动线程，就具有了异步执行的效果。\r\n\r\n### currentThread()\r\n\r\n> 例1：\r\n\r\n```\r\nnew Operate().start();\r\n\r\nclass Operate extends Thread{\r\n    @Override\r\n    public void run() {\r\n        super.run();\r\n        System.out.println(\"Thread.currentThread().getName():\" + Thread.currentThread().getName());\r\n        System.out.println(\"this.getName():\" + this.getName());\r\n    }\r\n}\r\n```\r\n结果：\r\n```\r\nThread.currentThread().getName():Thread-0\r\nthis.getName():Thread-0\r\n```\r\n----------\r\n> 例2：\r\n```\r\nOperate o = new Operate();\r\nThread t = new Thread(o);\r\nt.setName(\"A\");\r\nt.start();\r\n```\r\n结果\r\n```\r\nThread.currentThread().getName():A\r\nthis.getName():Thread-0\r\n```\r\n\r\n### isAlive()\r\n\r\n\r\n## 停止线程\r\n### 判断当前线程是否停止的两种方法\r\n* public static boolean interrupted() 判断当前线程是否已经中断，并具有清除状态的功能，即可能出现第一次调用时是true，第二次调用时是false\r\n* public boolean isInterrupted() 判断线程是否已经中断\r\n\r\n以下是停止线程的一个实践：\r\n```\r\n/**\r\n * 停止线程的最佳实践\r\n * 通过this.interrupt()与this.interrupted()配合(也可与this.isInterrupted()配合)停止线程\r\n * 使用或测试时，其中有几个坑需要注意：\r\n * 1. 主线程中的sleep时间不能太长，否则无法达到效果\r\n * 2. this.interrupted()判断线程是否停止时，需要抛出异常并即时捕获才能停止线程，也可以使用return停止线程，建议使用前者，因为具备传播性\r\n */\r\npublic class Run {\r\n    public static void main(String[] args) {\r\n        try {\r\n            MyThread tr = new MyThread();\r\n            tr.start();\r\n            // sleep时间过长，无法达到interrupt的效果\r\n            Thread.sleep(1);\r\n            tr.interrupt();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\npublic class MyThread extends Thread {\r\n\r\n    @Override\r\n    public void run() {\r\n        super.run();\r\n        try {\r\n            for (int i = 0; i < 100000; i++) {\r\n                if (this.interrupted()) {\r\n                    System.out.println(\"我要退出了\");\r\n                    // 注释掉下一句试试\r\n                    throw new InterruptedException();\r\n                }\r\n                System.out.println(i);\r\n            }\r\n            System.out.println(\"我还是被输出了，看来没有真正的停掉我啊\");\r\n        } catch (InterruptedException e) {\r\n            System.out.println(\"捕获到run方法的catch了\");\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n## 线程的优先级\r\n\r\n## 同步与死锁\r\n\r\n## 对象及变量的并发访问\r\n\r\n锁实现的方法synchronized\r\n锁对象可以是this对象，也可以是非this对象，非this对象时一定要保证线程共享一个对象\r\n\r\n\r\n',1,'post','publish','Java,多线程','Java多线程',46,0,1,1,1),(5,'Mysql安装配置以及常用方法',NULL,1515333611,1515395289,'# 前言\r\n由于Mysql的安装大多跟服务器的类型与版本有关系，本文基于CentOS7来安装\r\n# 安装步骤\r\n* 下载MySQL官方Yum Repository\r\n    * `wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm`\r\n* 安装yum Repository\r\n    * `yum -y install mysql57-community-release-el7-10.noarch.rpm`\r\n* 安装服务器\r\n    * yum -y install mysql-community-server\r\n# 数据库设置\r\n* 启动\r\n    * `systemctl start  mysqld.service`\r\n*  查看状态\r\n    * `systemctl status mysqld.service`\r\n* 查看初始密码\r\n    * `grep \"password\" /var/log/mysqld.log`\r\n* 无密码进入数据库\r\n    * `mysql -uroot -p`\r\n* 查看密码规则\r\n`SHOW VARIABLES LIKE \'validate_password%\';`\r\n此时validate_password_check_user_name的值为ON，validate_password_length的值为8；测试时通常需要设置一些简单的密码，因此这里需要修改这两个值\r\n```\r\nmysql> set global validate_password_policy=0;\r\nmysql> set global validate_password_length=1;\r\n```\r\n如果没有以上设置，当修改密码时会出现：`your password does not satisfy the current policy requirements`的错误提示\r\n* 卸载Yum Repository\r\n因为yum操作都会自动更新，因此将其卸载：`yum -y remove mysql57-community-release-el7-10.noarch`\r\n# 修改密码\r\n`ALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'new password\';`\r\n# 数据库的导入导出\r\n## 导入\r\n### mysql终端导入方式\r\n进入mysql终端\r\n```\r\nmysql -u root -p\r\ncreate database name;\r\nuse name;\r\nsource /Users/qcxiao/like/test.sql\r\n```\r\n### 系统终端导入方式\r\n也可以在系统终端中直接导入，`mysql -h localhost -u root -p testbase < test.sql`\r\n## 导出\r\n进入系统终端，`mysqldump -u 用户名 -p 数据库名 > 导出的地址/导出的文件名`，例如：`mysqldump -u root -p testbase>test.sql`。导出一个表，`mysqldump -u 用户名 -p 数据库名 表名> 导出的地址/导出的文件名`\r\n如果出现`mysqldump: command not found`错误，需要将mysqldump加入到系统环境变量中，在MAC的路径是`/usr/local/mysql/bin`\r\n\r\n# 权限控制\r\n* 增加允许远程访问的用户或者允许现有用户的远程访问\r\n\r\n    `grant all privileges on *.* to \'root\'@\'%\' identified by \'123456\' with grant option;`\r\n\r\n* 指定访问主机\r\n如果需要指定访问主机，可以把%替换为主机的IP或者主机名。另外，这种方法会在数据库mysql的表user中，增加一条记录。如果不想增加记录，只是想把某个已存在的用户（例如root）修改成允许远程主机访问，则可以使用如下SQL来完成：\r\n\r\n    `update user set host=\'%\' where user=\'root\' and host=\'localhost\';`\r\n\r\n* 重启mysql\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Mysql','Mysql',42,0,1,1,1),(6,'Docker常规操作',NULL,1515418281,1516945840,'# 前言\r\n记录Docker常规套路操作，以防忘记；操作环境CentOS7\r\n# 安装部署\r\n## 安装\r\nDocker 软件包和依赖包已经包含在默认的 CentOS-Extras 软件源里，安装命令如下：\r\n\r\n    yum -y install docker\r\n## 启动\r\n\r\n    systemctl start docker\r\n## 测试\r\n\r\n    docker run hello-world\r\n启动一个hello-world的镜像，查看运行的情况\r\n## 停止\r\n\r\n    systemctl stop docker\r\n\r\n# 镜像操作\r\n## 查看镜像\r\n\r\n    docker images\r\n## 删除镜像\r\n前提是此镜像没有已创建的容器，如果有需要先停止容器再删除容器\r\n\r\n    docker rmi <IMAGE ID>\r\n当有多个镜像的IMAGE ID相同时，可以通过`docker rmi <REPOSITORY:TAG>`\r\n\r\n# 容器操作\r\n## 查看正在运行的容器\r\n\r\n    docker ps\r\n## 查看所有容器\r\n\r\n    docker ps -a\r\n## 启动容器\r\n\r\n    docker start <CONTAINER ID>\r\n## 进入容器\r\n进入容器即在容器的namespace内执行 shell\r\n### 标准姿势——exec\r\n`docker exec -it <CONTAINER ID> bash`\r\n### ssh\r\n不建议使用 ssh 进入容器, 关于为什么不建议使用, 请参考如下文章:\r\n\r\n* http://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/\r\n* http://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker\r\n\r\n### docker attach\r\n也可以使用 `docker attach <CONTAINER ID>`\r\n\r\n> 为什么执行 docker attach 卡住了?\r\n\r\n首先要明确的是 docker attach 不是一个用来进入容器的命令, 或者说他不是用来在容器内运行一个 bash(shell) 的命令, 它是用来连接到容器中运行中的进程, 也就是容器的 CMD, 容器内 PID=1 的那个进程, 如果这个进程没有 stdout/stderr 那么你将看不到任何输出, 如果它没有接收 stdin 你也无法发送指令给它. 这也就是为什么你运行一个 bash 的容器, 就可以 attach 进去执行命令, 而你运行一个 mysql server 的容器就无法操作的原因\r\n### 退出容器\r\n退出容器即退出在容器的namespace内执行shell，回到宿主机的终端\r\n这里要使用 CTRL-P CTRL-Q 来退出容器, 如果使用 CTRL+C 那么会导致容器结束(Exited), 因为它会发送 SIGKILL 给容器的进程, 然后这个容器就 Exited 了, 当然这里可以使用 `docker attach --sig-proxy=false` 防止发送 SIGKILL 给进程\r\n\r\n## 停止容器\r\n\r\n    docker stop <CONTAINER ID>\r\n## 删除容器\r\n\r\n    docker rm <CONTAINER ID>\r\n# 挂载\r\n`docker run -it --name ubuntu -h docker-qcxiao -v /Users/qcxiao/docker-volume ubuntu:16.04 /bin/bash`\r\n\r\n\r\n\r\n> 参考文献：<br>\r\n> https://www.lsproc.com/post/docker-faq#toc_16（Docker 常见问题 (FAQ)）<br>\r\n> http://www.open-open.com/lib/view/open1421996521062.html（Docker容器动态添加Volume）\r\n\r\n',1,'post','publish','Docker','Docker',33,0,1,1,1),(7,'Python正则表达式',NULL,1515419049,1515500948,'* ^表示以特定字符开头，在[]中表示非，在[.*]中.和*就没有特殊用途了\r\n* $表示以特定字符结束\r\n* .表示任意字符\r\n* *表示前面字符出现任意次\r\n* +表示前面字符至少出现一次\r\n* ?表示非贪婪匹配；（默认贪婪匹配，从后往前匹配）\r\n* {}表示前面字符出现的次数\r\n* ()用于提取字符串，可以结合group()的用法\r\n* []用于限制匹配的字符，即匹配[]中的字符，且在[]内的特殊字符没有特殊含义（可以是数字、字母等区间）\r\n* \\s表示空格（一个空格），\\S和\\s相反\r\n* \\w表示：[a-zA-Z0-9_]，\\W和\\w相反\r\n* [\\u4E00-\\u9FA5]：表示中文汉字\r\n* \\d表示数字，等价于：[0-9]\r\n\r\n具体见以下代码：\r\n\r\n```\r\nimport re\r\n\r\nline = \'haaaaaaahhhh12345\'\r\n# 正则表达式默认是贪婪的匹配模式,而?就是把模式改为非贪婪模式；因为贪婪匹配是从前向后一直匹配，因此贪婪匹配可以理解为从后向前开始匹配\r\n# ()表示提取子串\r\n# .表示任意字符\r\nregx_str1 = \'.*?(h.*?h).*\'\r\n# 限定：+表示至少出现一次，*表示可以出现任意次\r\nregx_str2 = \'.*(h.+h).*\'\r\n# {2}、{2,}、{2,5}具体的限定次数\r\n# {2}表示刚好2次\r\n# {2,}表示2次及以上\r\n# {2,5}表示至少2次，最多5次，这里一定要注意是否贪婪匹配\r\nregx_str3 = \'.*(h.{5,11}h).*\'\r\n\r\n\r\nmatchObj = re.match(regx_str1, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\nmatchObj = re.match(regx_str2, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\nmatchObj = re.match(regx_str3, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\nline = \'haaaaha123\'\r\n# |表示或，同时理解到group的用法\r\nregx_str4 = \'((ha|haaaaha)123)\'\r\nmatchObj = re.match(regx_str4, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n    print(matchObj.group(2))\r\n\r\n# []表示其中任意一个,[0-9]表示0到9的任意一个的区间，[^1]表示非1，[.*]这样.和*就没有特殊用途了\r\nline = \'138836666667\'\r\nregx_str5 = \'(1[345][0-9]{9})\'\r\nmatchObj = re.match(regx_str5, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\n# \\s表示空格；\\S表示非\\s，即不为空的字符\r\n# \\w表示[A-Za-z0-9_]，\\W表示非\\w\r\nline = \'h h\'\r\nregx_str6 = \'(h\\wh)\'\r\nmatchObj = re.match(regx_str6, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\nregx_str7 = \'(h\\Wh)\'\r\nmatchObj = re.match(regx_str7, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\n# [\\u4E00-\\u9FA5]中文匹配\r\nline = \'h 哈哈 中h\'\r\nregx_str8 = \'.*([\\u4E00-\\u9FA5]*)\'\r\nmatchObj = re.match(regx_str8, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\n# \\d表示数字\r\nline = \'h 哈哈 2018中h\'\r\nregx_str9 = \'.*?(\\d+中)\'\r\nmatchObj = re.match(regx_str9, line)\r\nif matchObj:\r\n    print(matchObj.group(1))\r\n\r\n```\r\n\r\n',1,'post','publish','Python','Python',4,0,1,1,1),(8,'自动化测试框架构建',NULL,1515419877,1515420140,'# 自动化测试框架从零到一\r\n\r\n## 前言\r\n自动化，已渗透到软件工程各领域中，也是迈向智能化的坚实一步。随着DevOps的发展与规模化应用，质量保障的担子越来越重，如何应对频繁迭代的产品节奏、如何加快产品交付速率，都对质量交付提出了严峻的考验。此刻，自动化测试显得很有必要，能够积极促进质效提升，保障质量交付的最后一环；但是就像我们熟知的那样，自动化测试的维护成本高，把握不当将会事倍功半；因此需要我们在实施的过程中精确的做一些可行性分析，抽丝剥茧般把自动化测试用在可行的流程与模块中。\r\n\r\n在本文，我们不分析自动化测试的可行性，也不讨论如何保障自动化测试的收益。我们只讨论如何从零到一构建自动化测试框架，帮助我们在B/S端、移动端、C/S端执行测试且快速生成日志结果，通过丰富日志结果帮助我们快速发现问题、定位问题。\r\n\r\n在本文，我们定位的是一个轻量级的框架而非一个大而全的平台，旨在方便使用。\r\n## 如何驱动\r\n任何事件都是需要驱动才能完成的，执行自动化测试也一样。这里我们采用数据驱动与关键字驱动相结合的方式实现最终驱动，且实现脚本与用例完全解耦。\r\n基于Junit（当然也可以是其它，如TestNG）增加模块驱动，递归获取数据库、Excel表格等数据文件的行级数据做为测试用例，完善用例执行机制形成特有的数据驱动方式；经过执行测试、收集测试结果、断言预期与实际结果、利用模板技术最终形成测试报告。\r\n\r\n基于Selenium、Appium等开源框架，封装不同浏览器对象、不同移动端对象、HTML元素对象等，扩展形成关键字驱动。\r\n\r\n因此数据驱动则是贯穿整体控制逻辑的驱动，而关键字驱动可以看作是行为或事件的驱动；接下来我们分别看看数据驱动和关键字驱动。\r\n### 数据驱动\r\n上面已经介绍到数据驱动是以Junit为基础的驱动方式，针对测试模块（即方法或函数）执行测试前收集测试用例数据，递归调用每一条行级数据，通过注解方式注入到测试方法中；驱动器在不同的测试阶段通过观察者模式发布订阅更新套件、模块、用例、日志对象数据，驱动器再调用执行器执行用例最后生成报告，如下图：![](/assets/自动化测试框架架构图-数据驱动 %283%29.png)这里面有几个关键的点，接下来将一一说明。\r\n#### 如何注入驱动器\r\n```\r\n@Rule\r\npublic DriverService driverService = new DriverService();\r\n```\r\n这是Junit Rule的用法，DriverService只需要实现TestRule接口和覆盖Statement apply方法即可。\r\n同时是一个类的成员变量并且需要实例化，当本套件中有多个模块时，可以共用驱动器。\r\n#### 如何开始\r\n* 像普通测试方法一样，在方法上面加上@Test注解\r\n\r\n```\r\n@Test\r\npublic void testStart() {\r\n\r\n}\r\n```\r\n* 在驱动器中调用执行\r\n```\r\nbase.evaluate();\r\n```\r\n以上两个步骤均是基于Junit的机制，为了方便控制实现，只需要自己构建一个驱动器即可。\r\n#### 如何注入数据\r\n```\r\n@Test\r\n@DataSource(type = DataSourceType.EXCEL, file = \"selendroid-test-app.xls\", sheetName = \"sheet1\")\r\npublic void testStart() {\r\n\r\n}\r\n```\r\n通过Junit的Description获取DataSource自定义注解的类型和位置，从而读取指定的数据文件。\r\n#### 如何执行数据\r\n通过上一步骤获取到的数据为行级测试用例存到一个集合对象中，再从对象中循环获取所得数据，每一次拿到的数据都是整个链路所需数据，通过调用evaluate\\(\\)方法则可一次次执行用例且轮询执行测试方法中的方法体。\r\n#### 动态更新对象数据\r\n如何更新套件、模块、用例、日志对象中的数据，且保持一致？这里我们可以通过观察者模式的推模型，在套件开始结束、模块开始结束、用例开始结束时将所有数据更新都推送到订阅者对象，保证了数据更新的一致性，保证生成的日志报告数据的一致性和正确性。\r\n### 关键字驱动\r\n以下都是以PC端的B/S为例来说明关键字驱动，IOS与Android、C/S的处理逻辑类似。\r\n关键字驱动需要达到的目标就是可重用、易理解、便排错，不同浏览器可使用同一套脚本和用例开展测试。\r\n总体来说测试对象可以分为两个方面，一个是浏览器对象，另一个是HTML元素对象。\r\n* 浏览器对象很简单，主要负责打开退出浏览器，浏览器初始配置等，并持续与元素对象保持交互\r\n* HTML元素对象是在Selenium、Appium、AutoIt等开源测试框架基础上、以HTML元素等为关键字、以对应元素属性为操作动作封装的一套逻辑驱动。抽象出了一堆如button、div、table、form、link等HTML的元素对象，并为了针对不熟悉框架的使用者，再抽象出Element对象兼容到所有元素的操作动作，以此解决易用性的问题以及丰富以上开源框架的处理逻辑（如元素等待、操作重试等）\r\n接下来，我们有如下问题需要解决：\r\n* 如何联系浏览器对象和元素对象\r\n* 如何定位元素以及多层级元素\r\n* 如何定位元素属性不确定性的元素\r\n* 如何定义不同元素的不同操作\r\n* 如何建立重试或等待机制\r\n#### 联系浏览器对象和元素对象\r\n首先应该明确以下两点：\r\n* 元素对象的定位与操作都离不开浏览器对象，都是以浏览器对象为基础的\r\n* 元素对象与浏览器对象应该保持时时通信\r\n根据以上两点不难看出元素对象不能单独存在，而浏览器对象是可以的（比如浏览器的打开与退出）；因此元素对象需要跟浏览器对象放在同一容器中才能使元素对象有生命周期和可操作性，容器底层都依赖WebDriver同时基于JsonWireProtocol协议，从而解决了浏览器可以随时调用元素操作问题以及两者之前的通信问题。\r\n#### 定位元素以及多层级元素\r\n众所周知，基于Selenium（即WebDriver）的元素定位有ID、Name、Class、CSS、以及终极定位XPATH，因此我们也将以此为基础做为定位方法，结合之前介绍的每个HTML元素都抽象出相应的对象，可以更加准确的定位元素。\r\n多层级元素的定位，主要用于元素属性不唯一时，需要层层定位父级元素直到元素属性唯一。\r\n```\r\nBrowser br = ChromeBrowser.start(\"www.taobao.com\");\r\nbr.element(\"id=>ks-component1124\").input(\"id=>q\").set(\"男装\");\r\n```\r\n从以上代码可以看出：\r\n* 通过=>来指定元素属性与属性值\r\n* id为q的元素在整个HTML页面可能不唯一时，需要定位到父级元素，就是所谓的多层级元素定位\r\n#### 定位元素属性不确定性的元素\r\n元素不确定性的原因，可能是某个元素不一定存在，不同的业务场景可能会有不同的元素，这里通过XPATH都是无法定位的。\r\n根据以上应用场景，这里举个栗子，比如当我们出去旅游需要选择航班以及舱位，可能因为不同的航班或时间可选择的舱位信息都是不相同的。如何根据业务场景来选择对应的舱位，如果都转化为XPATH来定位可能会导致大量用例的元素定位失败，因此XPATH在这里是不严谨的写法。\r\n此时我们就需要根据元素当前所在的位置来定位，通过相对坐标转化为JS等来操作元素，如下：\r\n```\r\nbr.element(\"id=>ks-component1124\").input(\"id=>q,index=>1\").set(\"男装\");\r\n```\r\n#### 定义不同元素的不同操作\r\n不同元素的不同操作其实就是不同元素都应该有对应的HTML动作。基于元素都是抽象出来的对象，所以我们可以定制相应的操作动作到对象中，如下：\r\n```\r\nbr.input(\"id=wq\").set(\"淘淘淘\");\r\nbr.button(\"class=>btn-search\").click();\r\n```\r\ninput元素有填充值动作，而button有点击动作；这就需要个性化抽象对象。\r\n#### 等待或重试\r\n这也是丰富底层框架的一个关键，因为网速或页面元素的复杂性以及懒加载，可能导致有些元素无法第一时间加载，这时就需要等待或者重试。\r\n```\r\ncurrent = (new WebDriverWait(container.driver, TIMEOUT)).until(new ExpectedCondition<WebElement>() {\r\n    @Override\r\n    public WebElement apply(WebDriver input) {\r\n        return locator.locate();\r\n    }\r\n});\r\n```\r\n### 结合关键字驱动和数据驱动\r\n```\r\n@Test\r\n@DataSource(type = DataSourceType.EXCEL, file = \"taotaotao.xls\", sheetName = \"Sheet1\")\r\npublic void test2(){\r\n    Browser br = ChromeBrowser.start(\"www.taobao.com\");\r\n    br.element(\"id=>ks-component1124\").input(\"id=>q,index=>\" + driverService.param.get(\"id\")).set(\"男装\");\r\n    br.button(\"class=>btn-search\").click();\r\n}\r\n```\r\n## 写在最后\r\n综上所述，我们从关键字驱动和数据驱动两个维度介绍了整体框架的构建思路，当然数据驱动是整个框架的核心是解耦的关键，实现了方法体的循环执行，还使脚本能够专注于执行行为或动作。当然还有一些日志的生成以及对于异常的处理、预期和实际值的断言等等，这里都略过了。\r\n框架还有许多的可拓展性，比如集成到持续集成环境中，且框架也继承Grid的功能，可以使用Docker构建多个统一且可控制的沙箱执行环境，再通过phantomjs在Linux环境下实现多Node执行。\r\n不可否认自动化测试框架只是工具，如何更好的开展自动化测试取决于我们的业务场景是否满足和可行性分析是否充分。\r\n\r\n',1,'post','draft','自动化测试','自动化测试',4,0,1,1,1),(9,'Git常规操作',NULL,1515420214,1515420346,'* 初始化\r\n`git init`\r\n\r\n* 保存、提交\r\n```\r\ngit add <filename>\r\ngit commit -m \"\" \r\n```\r\n* 状态查看与修改查看\r\n```\r\ngit status\r\ngit diff\r\n```\r\n* 提交日志\r\n```\r\ngit log \r\ngit log --pretty=oneline\r\n```\r\n* 版本回退\r\n```\r\ngit reset --hard HEAD^ #回退到上一个版本\r\ngit reset --hard HEAD~100 #回退到前100个版本\r\n```\r\n* 回退找回\r\n```\r\ngit reflog\r\ngit reset --hard <commit id>\r\n```\r\n* 工作区（Working Directory）和版本库（Repository）\r\n	* 工作区，就是init目录下的文件\r\n	* 版本库，隐藏目录.git\r\n		* HEAD，指向master的指针\r\n		* stage表示暂存区\r\n		* master等分支\r\n	commit就是建立stage向master提交修改的方式，因此commit只是针对修改而不是针对文件\r\n\r\n* 撤销修改\r\n`git checkout -- <filename> #其中--表示用来分隔文件，如果没有就表示切换分支了`\r\n	* 一种是文件修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\r\n	* 一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态;\r\n	* 总之，就是让这个文件回到最近一次git commit或git add时的状态，如果是要撤销掉commit或add之后的文件，需要：git reset HEAD file\r\n\r\n* 撤销总结：\r\n	* 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\r\n	* 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。\r\n	* 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\r\n\r\n* 删除文件\r\n	* 误删，`git checkout -- <filename>`恢复工作区\r\n	* 确认需要删，git rm并且git commit\r\n\r\n* 远程仓库\r\n	* 添加远程仓库\r\n	`git remote add origin git@github.com:yaodao/git.git`\r\n	* 推送\r\n		* 首次推送，关联本地master与远程master分支，`git push -u origin master`\r\n		* 非首次推送，`git push origin master`\r\n\r\n* 仓库克隆\r\n`git clone <repositoryUrl>`\r\n	 这是的仓库地址可以是https协议，也可以是ssh支持的git协议，其中git协议速度更快 	\r\n\r\n* 分支\r\n```\r\n查看分支：git branch\r\n创建分支：git branch <name>\r\n切换分支：git checkout <name>\r\n创建+切换分支：git checkout -b <name>\r\n合并某分支到当前分支：git merge <name>\r\n删除分支：git branch -d <name>\r\n```\r\n\r\n* 创建分支并切换\r\n`git checkout -b <branchName>`\r\n相当于：\r\n```\r\ngit branch <branchName>\r\ngit checkout <branchName>\r\n```\r\n* 查看分支\r\n`git branch`\r\n\r\n* 合并分支\r\n将某个分支合并到当前分支：`git merge <branchName>`\r\n例如，当前分支是master，将dev分支合并到当分支：`git merge dev`\r\n当然这是一种Fast-forward，即“快速模式”合并\r\n\r\n* 删除分支\r\n`git branch -d <branchName>`\r\n强行删除：`git branch -D <branchName>`\r\n\r\n* 解决冲突\r\n	* 首先通过git merge得到合并失败的文件\r\n	* 手动解决冲突的文件\r\n	* 提交修改\r\n	* 当前分支的HEAD就会向后移动一个指针\r\n	* 删除被合并分支\r\n	* 查看分支合并图：`git log --graph --pretty=oneline --abbrev-commit`\r\n\r\n\r\n* 分支管理策略\r\nFast forward模式，删除分支后，会丢掉分支信息；可以通过--no-ff模式，删除分支后也会保存分支信息\r\n`git merge --no-ff -m \"merge with no-ff\" dev`\r\n	* 本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去\r\n	* 还会查看到被合并分支的历史commit信息\r\n* \"储藏\"分支\r\n储藏：`git stash`，查看列表：`git stash list`，\r\n	* 恢复，有两种方式\r\n		* 先恢复：`git stash apply`，再删除：`git stash drop`\r\n		* 恢复并删除：`git stash pop`\r\n\r\n* 多人协作\r\n远程库的信息：`git remote`，详细信息：`git remote -v`\r\n* 推送分支\r\n`git push origin master`，远程仓库的默认名称是origin，master是本地的分支；如果本地分支有，而远程没有时，会在远程自动创建一个同名分支\r\n\r\n* 抓取分支\r\nclone时，在本地只能看到master分支，希望获取到更多远程分支，需要：`git checkout -b dev origin/dev`\r\n当push时遇到冲突，需要使用`git pull`把最新的代码拉取下来，解决冲突再push，过程中可能需要将本地dev分支与远程origin/dev分支的链接`git branch --set-upstream dev origin/dev`，再pull\r\n\r\n因此，多人协作的工作模式通常是这样：\r\n首先，可以试图用`git push origin branch-name`推送自己的修改；\r\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\r\n如果合并有冲突，则解决冲突，并在本地提交；\r\n没有冲突或者解决掉冲突后，再用`git push origin branch-name`推送就能成功！\r\n如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream branch-name origin/branch-name`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Git','git',26,0,1,1,1),(10,'第一章 Python基础语法',NULL,1515420452,1515500695,'## Python与JAVA的差异比较\r\n* Python是解释型语言，Java是编译型语言；\r\n* Python比Java的运行速度慢，但是实现相同功能的代码少；\r\n* 根据语言强弱特性，Python是动态语言，Java是静态语言；\r\n## 变量与数据类型\r\n* 浮点数，可以使用科学记数法，0.000012可以写成1.2e-5\r\n* 字符串，它是以\"\"或\'\'括起来的任意文本\r\n* 布尔值，True、False(注意大小写)\r\n* 逻辑运算符，and、or、not\r\n* 空值，None\r\n* 注释，以 # 开头到后面的文字直到行尾都算注释\r\n* 转义，通过\\转义\r\n* raw字符串与多行字符串，r\'...\'表示一个raw字符串，里面的字符就不需要转义了，但是不能包含多行字符串和包含\'、\"的字符串；可以使用\'\'\'...\'\'\'表示多行字符串\r\n* 对Unicode的支持，u\'中文\'，就可以正常显示中文，可以与r和\'\'\'联合使用；如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题，可以在第一行添加注释`#-*- coding: utf-8 -*-`',1,'post','publish','Python','Python学习笔记',21,0,1,1,1),(11,'第二章 Python数据类型',NULL,1515420562,1517111501,'# 简单数学运算、变量赋值\r\n与Java类似，这里不再举例\r\n# 字符串\r\n字符串赋值时\'与\"是一样的\r\n## 字符串赋值\r\n```\r\ns = \'\'\'hello\r\nworld\'\'\'\r\n```\r\n\'\'\'是包含多行文字的字符串\r\n## 字符串索引\r\n```\r\ns = \'hello python\'\r\ns[0] -> h\r\ns[-1] -> n\r\ns[0:5] -> hello \r\ns[0:] -> \'hello python\'\r\n```\r\n## 字符串的分割\r\n`s.split() -> [\'hello\', \'python\']`\r\n## 字符串的长度\r\n`len(s)->12`\r\n\r\n# 列表List\r\n## 列表的访问与替换\r\n* 列表是一种有序的集合，可以随时删除和添加元素，因为是动态语言所以list可以包含各种类型，如：names = [\'haha\', 1, True]，也可以为空。Python中List可以通过负数逆向访问，如names[-1]指向True\r\n* 列表可以通过索引赋值，直接替换元素\r\n* 列表没有提供get方法获取元素\r\n## 列表的截取\r\n与字符串类似\r\n## 索引和长度\r\n列表的索引和长度跟字符串类似\r\n## 列表的加法\r\n\r\n```\r\na = [1,2]\r\nb = [True,\'hello\']\r\na + b\r\n[1, 2, True, \'hello\']\r\n```\r\n\r\n## 列表的减法\r\n* 可以通过列表自己的pop()方法删除最后一个元素并且会返回删除的这个元素，当带一个参数时，可以指定索引来删除元素\r\n* 也可以通过del函数删除，但是不会返回删除的这个元素\r\n```\r\n>>> c = [True,None,\'a\',1]\r\n>>> c.pop(2)\r\n\'a\'\r\n>>> c\r\n[True, None, 1]\r\n>>> del c[1]\r\n>>> c\r\n[True, 1]\r\n```\r\n\r\n## 列表的乘法\r\n\r\n```\r\n>>> a = [1, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n>>> a\r\n[1, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n>>> a*2\r\n[1, [3, 4, 5], 6, 7, 8, \'9\', 10, 1, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n```\r\n\r\n## 列表动态增长\r\nList可以通过append()或extend()方法将新元素添加到集合的末尾；也可以通过insert()方法添加到想要添加的位置，它接受两个参数（必须是两个参数），第一个参数是索引号，第二个参数是待添加的新元素，后面的所有元素向后移一个索引\r\n### insert用法\r\n```\r\n>>> a\r\n[1, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n>>> a.insert(1,[\'a\'])\r\n>>> a\r\n[1, [\'a\'], [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n>>> a.insert(\'11\')\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: insert() takes exactly 2 arguments (1 given)\r\n>>> a.insert(-1,\'11\')\r\n>>> a\r\n[1, [\'a\'], [3, 4, 5], 6, 7, 8, \'9\', \'11\', 10]\r\n```\r\n### append与extend的异同\r\n* append向列表尾部追回任意元素数据\r\n* extend向列表尾部扩展iterable元素数据，即使用一个序列扩展另一个iterable\r\n* 均向列表尾部增添元素\r\n\r\n```\r\n\r\n>>> a = [1,2]\r\n>>> a.append([3,4,5])\r\n>>> a\r\n[1, 2, [3, 4, 5]]\r\n>>> a.extend([6,7,8])\r\n>>> a\r\n[1, 2, [3, 4, 5], 6, 7, 8]\r\n>>> a.extend(9)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: \'int\' object is not iterable\r\n>>> a.extend(\'9\')\r\n>>> a\r\n[1, 2, [3, 4, 5], 6, 7, 8, \'9\']\r\n>>> a.append(10)\r\n>>> a\r\n[1, 2, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n```\r\n> append是追加，extend是扩展，从字面上也大概能够理解其涵义\r\n* 这里有一个特别需要注意的地方，为什么extend(\'9\')和extend([6,7,8])是成立的，而extend(9)不成立；因为extend方法必须满足参数是一个可迭代的对象，\'9\'是一个字符串，字符串和列表内部实现了迭代器对象接口__iter__或者__getitem__，因此字符串和列表是一个可迭代对象；然而int不是，因此才会有`TypeError: \'int\' object is not iterable`的异常。\r\n\r\n## 列表的迭代\r\n\r\n```\r\n>>> a = [1, [3, 4, 5], 6, 7, 8, \'9\', 10]\r\n>>> for x in a:\r\n...     print(x)\r\n... \r\n1\r\n[3, 4, 5]\r\n6\r\n7\r\n8\r\n9\r\n10\r\n```\r\n\r\n# 字典dict\r\n类似于Java中的Map，key-value的的形式存储数据，特点:\r\n\r\n* dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。\r\n* 而list的查找速度随着元素增加而逐渐下降。\r\n* 不过dict的查找速度快是有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小但是查找速度慢。\r\n* 由于dict是按 key 查找，所以在一个dict中key不能重复。\r\n* dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样\r\n* dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。可变的就不能作为 key，如列表。\r\n\r\n## 申明dict\r\n\r\n```\r\nd = {\r\n    \'Adam\': 95,\r\n    \'Lisa\': 85,\r\n    \'Bart\': 59\r\n}\r\n```\r\n\r\n通过len\\(\\)函数，如len\\(d\\)获取d的长度。\r\n\r\n## 访问dict\r\n\r\n通过d\\[\'Adam\'\\]就可以得到其值95，当key不存在时报KeyError错误。避免KeyError的方法：\r\n\r\n* 使用if判断key是否存在于dict中，如：if \'Paul\' in d:\r\n* 使用dict本身的get方法，当key不存在时，返回None\r\n\r\n## 更新dict\r\n\r\ndict是可变的，因此可以随时往dict里添加key-vaule。如果key存在，会覆盖value，如果key不存在，直接添加key-value。\r\n\r\n# 集合Set\r\n> set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。\r\n\r\n## 创建Set\r\n创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：\r\n\r\n```\r\n\r\n>>> s = set([\'A\', \'B\', \'C\']) # 必须这样定义，不能使用s = ([\'a\',\'b\',\'c\'])\r\n>>> print s\r\nset([\'A\', \'C\', \'B\']) #Python2\r\n{\'B\', \'A\', \'C\'} # Python3\r\n```\r\n> 虽然在不同版本下，输出s的样子不一样，但是类型都是Set\r\n\r\n请注意，上述打印的形式类似list但不是list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。因此：\r\n\r\n```\r\n>>> s = set([\'A\', \'B\', \'C\', \'C\'])\r\n>>> print s\r\nset([\'A\', \'C\', \'B\'])\r\n>>> len(s)\r\n3\r\n```\r\n## 访问Set\r\nSet存储的是无序集合，因此无法通过索引来访问Set，可以通过in来判断元素是否存在set中\r\n```\r\n>>> s = set([\'Adam\', \'Lisa\', \'Bart\', \'Paul\'])\r\n>>> \'Bart\' in s\r\nTrue\r\n```\r\n## 遍历Set\r\n遍历 set 和遍历 list 类似，都可以通过 for 循环实现。\r\n\r\n直接使用 for 循环可以遍历 set 的元素：\r\n```\r\n>>> s = set([\'Adam\', \'Lisa\', \'Bart\'])\r\n>>> for name in s:\r\n...     print name\r\n... \r\nLisa\r\nAdam\r\nBart\r\n```\r\n## 更新Set\r\n添加元素时，用set的add()方法：\r\n```\r\n>>> s = set([1, 2, 3])\r\n>>> s.add(4)\r\n>>> print s\r\nset([1, 2, 3, 4])\r\n```\r\n如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：\r\n\r\n```\r\n>>> s = set([1, 2, 3])\r\n>>> s.add(3)\r\n>>> print s\r\nset([1, 2, 3])\r\n```\r\n删除set中的元素时，用set的remove()方法：\r\n\r\n```\r\n>>> s = set([1, 2, 3, 4])\r\n>>> s.remove(4)\r\n>>> print s\r\nset([1, 2, 3])\r\n```\r\n\r\n如果删除的元素不存在set中，remove()会报错。\r\n\r\n# 元组Tuple\r\n* tuple 和 list 非常类似，但是tuple一旦创建完毕，就不能修改了；创建tuple和创建list唯一不同之处是用\\(\\)替代了\\[\\]\r\n* tuple没有pop\\(\\)、append\\(\\)、insert\\(\\)等方法，也不能索引赋值替换\r\n* 定义单元素时需要使用\\(1,\\)来定义，不加\",\"会被直接解析为1\r\n* 强调：tuple的不能修改是指指向不能变\r\n',1,'post','publish','Python','Python学习笔记',86,0,1,1,1),(12,'SpringBoot整合Docker实现应用部署',NULL,1515464772,1515481201,'# 前言\r\n目前SpringBoot的易于部署等优点已经得到大范围的应用，以及Docker的容器化带来的更高效的利用系统资源、更快速的启动时间、一致的运行环境、持续交付和部署等众多特点，所以在之前就迫不及待的拿来试用，包括本网站也是使用这套部署方式，并且结合阿里云实现云端轻松部署，今天就来说说如何集成这套环境。\r\n# 插件集成\r\n* 在应用项目的pom.xml(当然也可以是Gradle)中，依赖docker-maven-plugin插件\r\n* 集成maven构建命令与docker构建的关系\r\n* 配置私有仓库的映射\r\n* 指定DockerFile的路径\r\n* 将打包后的文件放入指定路径\r\n详细代码如下：\r\n\r\n```\r\n<build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>com.spotify</groupId>\r\n                <artifactId>docker-maven-plugin</artifactId>\r\n                <version>${docker.plugin.version}</version>\r\n                <executions>\r\n                    <execution>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>build</goal>\r\n                        </goals>\r\n                    </execution>\r\n                    <execution>\r\n                        <id>push-image</id>\r\n                        <phase>deploy</phase>\r\n                        <goals>\r\n                            <goal>push</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <imageName>${docker.registry.url}/${docker.registry.name}/${project.artifactId}:${project.version}</imageName>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n                <configuration>\r\n                    <!-- 私有仓库配置，需要settings.xml文件配合serverId对应的服务地址 -->\r\n                    <serverId>docker-aliyun</serverId>\r\n                    <registryUrl>registry.cn-hangzhou.aliyuncs.com</registryUrl>\r\n                    <!-- 设置为true时，mvn install也会上传到docker私服 -->\r\n                    <pushImage>true</pushImage>\r\n                    <!-- 指定DockerFile的路径 -->\r\n                    <dockerDirectory>${project.basedir}/src/docker/MyBlog</dockerDirectory>\r\n                    <imageName>\r\n                        ${docker.registry.url}/${docker.registry.name}/${project.artifactId}:${project.version}\r\n                    </imageName>\r\n                    <resources>\r\n                        <rescource>\r\n                            <!-- 将打包文件放入dockerDirectory指定的路径 -->\r\n                            <targetPath>/</targetPath>\r\n                            <directory>${project.build.directory}</directory>\r\n                            <include>${project.build.finalName}.jar</include>\r\n                        </rescource>\r\n                    </resources>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n```\r\n插件的版本以及仓库地址与名称：\r\n```\r\n<properties>\r\n        <docker.registry.url>registry.cn-hangzhou.aliyuncs.com</docker.registry.url>\r\n        <docker.registry.name>yaodao</docker.registry.name>\r\n        <docker.plugin.version>0.4.13</docker.plugin.version>\r\n</properties>\r\n```\r\n当然这里需要去Docker仓库创建一个我们私有仓库\r\n# Docker registry的设置 \r\nDocker registry的设置主要涉及settings.xml配置私有库的访问\r\n* settings.xml设置\r\n使用自己的私有仓库访问密码生成服务密码，将生成的密码写入到settings.xml的<services>中，即：`mvn --encrypt-password <password>`\r\n```\r\n<server>\r\n        <id>docker-aliyun</id>\r\n        <username>xxxx@aliyun.com</username>\r\n        <password>{*****fI88HfSHS7UiVnq6qCKIxPoR+xh8******}</password>\r\n        <configuration>\r\n                <email>xxx@aliyun.com</email>\r\n        </configuration>\r\n    </server>\r\n```\r\n* settings-security.xml设置\r\n在setting.xml文件同路径下新建settings-security.xml文件，交以下内容写入文件，使用自己的私有仓库访问密码生成主密码，即：`mvn --encrypt-master-password <password>`,将生成的主密码写入password字段\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<settingsSecurity>\r\n  <master>{*****NSC9t0EHPON1F/9HGCfht7ND36mFWN*********}</master>\r\n</settingsSecurity>\r\n```\r\n# 执行命令\r\n`mvn clean install -Dmaven.test.skip=true -s ~/.m2/settings.xml`\r\n执行以上命令，会在本地Docker环境中打好一个镜像，并且同时会将此镜像push到私有仓库中。\r\n# 使用镜像\r\n* 登录Docker私有仓库\r\n`docker login --username=***@aliyun.com registry.cn-hangzhou.aliyuncs.com`\r\n* 下载仓库镜像\r\n`docker pull registry.cn-hangzhou.aliyuncs.com/yaodao/blog:0.1`\r\n* 通过镜像运行\r\n`docker run -d -p80:8080 registry.cn-hangzhou.aliyuncs.com/yaodao/blog:0.1`\r\n',1,'post','publish','SpringBoot,Docker','SpringBoot',39,0,1,1,1),(13,'Android API学习笔记',NULL,1515483850,1515483850,'# 介绍\r\n## Application Fundamentals\r\n安装在设备上后，每个Android应用程序都位于自己的安全沙箱中：\r\n\r\n* Android操作系统是一个多用户Linux系统，其中每个应用程序是不同的用户。\r\n* 默认情况下，系统为每个应用程序分配一个唯一的Linux用户标识（该标识仅供系统使用，应用程序未知）。系统为应用程序中的所有文件设置权限，以便只有分配给该应用程序的用户ID才能访问它们。\r\n* 每个进程都有自己的虚拟机（VM），所以应用程序的代码与其他应用程序隔离运行。\r\n* 默认情况下，每个应用程序都在自己的Linux进程中运行。当任何应用程序的组件需要执行时，Android启动进程，然后在不再需要的时候关闭进程，或者系统必须为其他应用程序恢复内存。\r\nAndroid系统就实现了最小权限的原则。默认情况下，每个应用程序只能访问需要完成其工作的组件，而不能访问其他组件。\r\n应用程序可以与其他应用程序共享数据，也可以通过应用程序访问系统服务：\r\n* 可以安排两个应用程序共享相同的Linux用户ID，在这种情况下，他们可以访问彼此的文件。为了节约系统资源，具有相同用户ID的应用程序也可以安排在同一个Linux进程中运行并共享相同的VM（这些应用程序还必须使用相同的证书进行签名）。\r\n* 应用程序可以请求访问设备数据的权限，例如用户的联系人，SMS消息，可安装存储（SD卡），相机，蓝牙等。用户必须明确授予这些权限。\r\n\r\n特点：\r\n* Android程序设计讲究逻辑和视图分离。\r\n* 界面编写推荐在layout中而不推荐在activity中编写；通用的一种做法是，在布局文件中编写界面，然后在activity中引入进来。\r\n\r\n### App Components\r\nAndroid系统四大组件分别是Activity、Service、Broadcast Receiver和Content Provider.\r\n\r\n* Activities\r\nAn activity represents a single screen with a user interface. \r\n凡是在界面上看到的都是放到activity里的\r\n在AndroidManifest.xml中注册activity\r\n```\r\n// 注册activity\r\n<activity android:name=\".HelloWorldActivity\">\r\n	// 主activity，启动时就立即onCreate和onStart\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n</activity>\r\n```\r\nactivity具体实现：\r\n```\r\n// AppCompatActivity属于向下兼容的activity\r\npublic class HelloWorldActivity extends AppCompatActivity {\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.hello_world_layout);\r\n    }\r\n}\r\n```\r\n实现activity与layout的联动：\r\n```\r\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:id=\"@+id/hello_world_layout\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\r\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\r\n	tools:context=\"com.example.helloworld.HelloWorldActivity\">\r\n    <TextView\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Hello World!\" />\r\n</RelativeLayout>\r\n\r\n```\r\n* Services\r\nA service is a component that runs in the background to perform long-running operations or to perform work for remote processes.\r\n* Content providers\r\n* Broadcast receivers\r\n\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Android','Android',26,0,1,1,1),(14,'Anaconda使用',NULL,1515484549,1515484549,'## 功能介绍\r\nAnaconda是用于管理python版本切换的管理工具\r\n* 提供了包管理功能，\r\n* 提供环境管理的功能，功能类似 Virtualenv，解决了多版本Python并存、切换的问题。\r\n\r\n<!-- more -->\r\n\r\n## python版本管理\r\n```\r\n# 查看帮助\r\nconda -h \r\n# 基于python3.6版本创建一个名字为python36的环境\r\nconda create --name python36 python=3.6 \r\n# 激活此环境\r\nactivate python36  \r\nsource activate python36 # linux/mac\r\n# 再来检查python版本，显示是 3.6\r\npython -V  \r\n# 退出当前环境\r\ndeactivate python36 \r\n# 删除该环境\r\nconda remove -n python36 --all\r\n# 或者 \r\nconda env remove  -n python36\r\n# 查看所以安装的环境\r\nconda info -e\r\n```\r\n\r\n## conda的一些常用命令\r\n```\r\n# 查看当前环境下已安装的包\r\nconda list\r\n# 查看某个指定环境的已安装包\r\nconda list -n python34\r\n# 查找package信息\r\nconda search numpy\r\n# 安装package\r\nconda install -n python34 numpy\r\n# 如果不用-n指定环境名称，则被安装在当前活跃环境\r\n# 也可以通过-c指定通过某个channel安装\r\n# 更新package\r\nconda update -n python34 numpy\r\n# 删除package\r\nconda remove -n python34 numpy\r\n# 更新conda，保持conda最新\r\nconda update conda\r\n# 更新anaconda\r\nconda update anaconda\r\n# 更新python，假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本\r\nconda update python\r\n```\r\n## 设置代理镜像\r\n```\r\n# 添加Anaconda的TUNA镜像\r\nconda config --add channels ;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\r\n# TUNA的help中镜像地址加有引号，需要去掉\r\n\r\n# 设置搜索时显示通道地址\r\nconda config --set show_channel_urls yes\r\n\r\n# 移除某个Anaconda的TUNA镜像\r\nconda config --remove channels \';https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\' \r\n```',1,'post','publish','Python,Anaconda','Python',44,0,1,1,1),(15,'Dockerfile编写最佳实践',NULL,1515499724,1515499724,'# 目标:\r\n* 更快的构建速度\r\n* 更小的Docker镜像大小\r\n* 更少的Docker镜像层\r\n* 充分利用镜像缓存\r\n* 增加Dockerfile可读性\r\n* 让Docker容器使用起来更简单\r\n# 总结\r\n* 编写.dockerignore文件\r\n* 容器只运行单个应用\r\n* 将多个RUN指令合并为一个\r\n* 基础镜像的标签不要用latest\r\n* 每个RUN指令后删除多余文件\r\n* 选择合适的基础镜像(alpine版本最好)\r\n* 设置WORKDIR和CMD\r\n* 使用ENTRYPOINT (可选)\r\n* 在entrypoint脚本中使用exec\r\n* COPY与ADD优先使用前者\r\n* 合理调整COPY与RUN的顺序\r\n* 设置默认的环境变量，映射端口和数据卷\r\n* 使用LABEL设置镜像元数据\r\n* 添加HEALTHCHECK\r\n\r\n\r\n\r\n\r\n> 注：[全文转自](https://blog.fundebug.com/2017/05/15/write-excellent-dockerfile/)',1,'post','publish','Dockerfile','Docker',6,0,1,1,1),(16,'第三章 Python条件判断和循环',NULL,1515500353,1515500765,'# 条件判断和循环\r\n## if\r\n\r\n* 注意缩进，是四个空格\r\n* :是条件体的开始\r\n\r\n```\r\n>>> age = 20\r\n>>> if age >= 18:\r\n...     print \'your age is\', age\r\n...     print \'adult\'\r\n...\r\nyour age is 20\r\nadult\r\n```\r\n\r\n## if else\r\n\r\n```\r\nif age >= 18:\r\n    print \'adult\'\r\nelse:\r\n    print \'teenager\'\r\n```\r\n\r\n## if-elif-else\r\n\r\n关键字：elif\r\n\r\n```\r\nif age >= 18:\r\n    print \'adult\'\r\nelif age >= 6:\r\n    print \'teenager\'\r\nelif age >= 3:\r\n    print \'kid\'\r\nelse:\r\n    print \'baby\'\r\n```\r\n\r\n## for循环\r\n\r\n关键字：in\r\n\r\n```\r\nL = [\'Adam\', \'Lisa\', \'Bart\']\r\nfor name in L:\r\n    print name\r\n```\r\n\r\n## while循环\r\n\r\n```\r\nN = 10\r\nx = 0\r\nwhile x < N:\r\n    print x\r\n    x = x + 1\r\n```\r\n\r\n## break退出循环\r\n\r\n```\r\nsum = 0\r\nx = 1\r\nwhile True:\r\n    sum = sum + x\r\n    x = x + 1\r\n    if x > 100:\r\n        break\r\nprint sum\r\n```\r\n\r\n## continue跳出本次循环\r\n\r\n用法类似\r\n\r\n## 多重循环\r\n\r\n```\r\nfor x in [\'A\', \'B\', \'C\']:\r\n    for y in [\'1\', \'2\', \'3\']:\r\n        print x + y\r\n```\r\n',1,'post','publish','Python','Python学习笔记',35,0,1,1,1),(17,'第四章 Python函数',NULL,1515500460,1517117607,'## 函数的定义\r\n\r\n```\r\ndef fun():\r\n```\r\n\r\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。\r\n\r\n`return None`可以简写为`return`。\r\n\r\n## 函数的参数\r\n\r\n###  位置参数\r\n\r\n### 默认参数\r\n定义：\r\n```\r\ndef write(w=1):\r\n    pass\r\n```\r\n当调用write函数时，如果没有传参，就默认参数为1\r\n原则：\r\n\r\n* 必选参数在前，默认参数在后，否则Python的解释器会报错\r\n* 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数\r\n* 默认参数必须指向不变对象！\r\n\r\n查看一下如下代码：\r\n```\r\nIn [43]: def a(l=[]):\r\n    ...:     l.extend(\'s\')\r\n    ...:     return l\r\n    ...: \r\n\r\nIn [44]: a()\r\nOut[44]: [\'s\']\r\nIn [45]: a()\r\nOut[45]: [\'s\', \'s\']\r\n```\r\n\r\n第二次调用时，为什么是[\'s\', \'s\']而不是[\'s\']？原因是Python函数在定义的时候，默认参数就被计算出来了，当函数在处理过程中修改了默认参数的值，再次调用时就不再是默认参数定义时的值了。以上函数应该怎么修改呢？\r\n\r\n```\r\nIn [46]: def a(l=None):\r\n    ...:     if l == None:\r\n    ...:         l=[]\r\n    ...:     l.extend(\'s\')\r\n    ...:     return l\r\n    ...: \r\n\r\nIn [47]: a()\r\nOut[47]: [\'s\']\r\nIn [48]: a()\r\nOut[48]: [\'s\']\r\n```\r\n\r\n> 定义默认参数要牢记一点：默认参数必须指向不变对象！\r\n\r\n###  可变参数\r\n\r\n```\r\ndef calc(*numbers):\r\n    sum = 0\r\n    for n in numbers:\r\n        sum = sum + n * n\r\n    return sum\r\n```\r\n\r\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。\r\n\r\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\r\n\r\n```\r\n>>> nums = [1, 2, 3]\r\n>>> calc(nums[0], nums[1], nums[2])\r\n14\r\n```\r\n\r\nPython允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去，所以也可以这样做：\r\n\r\n```\r\n>>> nums = [1, 2, 3]\r\n>>> calc(*nums)\r\n14\r\n```\r\n\r\n`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。\r\n\r\n### 关键字参数\r\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\r\n```\r\ndef person(name, age, **kw):\r\n    print \'name:\', name, \'age:\', age, \'other:\', kw\r\n>>> person(\'Michael\', 30)\r\nname: Michael age: 30 other: {}\r\n>>> person(\'Bob\', 35, city=\'Beijing\')\r\nname: Bob age: 35 other: {\'city\': \'Beijing\'}\r\n>>> person(\'Adam\', 45, gender=\'M\', job=\'Engineer\')\r\nname: Adam age: 45 other: {\'gender\': \'M\', \'job\': \'Engineer\'}\r\n```\r\n也可以把该dict转换为关键字参数传进去：\r\n```\r\n>>> kw = {\'city\': \'Beijing\', \'job\': \'Engineer\'}\r\n>>> person(\'Jack\', 24, city=kw[\'city\'], job=kw[\'job\'])\r\nname: Jack age: 24 other: {\'city\': \'Beijing\', \'job\': \'Engineer\'}\r\n```\r\n当然，上面复杂的调用可以用简化的写法：\r\n```\r\n>>> kw = {\'city\': \'Beijing\', \'job\': \'Engineer\'}\r\n>>> person(\'Jack\', 24, **kw)\r\nname: Jack age: 24 other: {\'city\': \'Beijing\', \'job\': \'Engineer\'}\r\n```\r\n### 参数组合\r\n在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。\r\n```\r\ndef func(a, b, c=0, *args, **kw):\r\n    print \'a =\', a, \'b =\', b, \'c =\', c, \'args =\', args, \'kw =\', kw\r\n\r\n>>> func(1, 2)\r\na = 1 b = 2 c = 0 args = () kw = {}\r\n>>> func(1, 2, c=3)\r\na = 1 b = 2 c = 3 args = () kw = {}\r\n>>> func(1, 2, 3, \'a\', \'b\')\r\na = 1 b = 2 c = 3 args = (\'a\', \'b\') kw = {}\r\n>>> func(1, 2, 3, \'a\', \'b\', x=99)\r\na = 1 b = 2 c = 3 args = (\'a\', \'b\') kw = {\'x\': 99}\r\n>>> args = (1, 2, 3, 4)\r\n>>> kw = {\'x\': 99}\r\n>>> func(*args, **kw)\r\na = 1 b = 2 c = 3 args = (4,) kw = {\'x\': 99}\r\n```\r\n注意：\r\n* 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过`*args传入：func(*(1, 2, 3))`\r\n* 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过`**kw传入：func(**{\'a\': 1, \'b\': 2})`\r\n* 可变参数在函数调用后自动组装为一个tuple\r\n* 关键字参数在函数调用后自动组装为一个dict\r\n### 命名关键字参数\r\n\r\n## 函数的返回\r\nPython中函数可以返回一个值或返回多个值，如下：\r\n```\r\nIn [32]: def move(x, y, step, time=1):\r\n    ...:     return x+step+time,y+step+time\r\n    ...: \r\n\r\nIn [33]: a,b = move(1,2,3)\r\nIn [34]: print a,b\r\n5 6\r\nIn [35]: c = move(1,2,3)\r\nIn [36]: print c\r\n(5, 6)\r\n```\r\n原来返回多个值其实是假象，真正的是返回一个tuple！多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但使用方便且可读性强。\r\n## 递归函数\r\n\r\n最常见的递归函数就是阶乘：\r\n\r\n```\r\ndef fact(n):\r\n    if n==1:\r\n        return 1\r\n    return n * fact(n - 1)\r\n```\r\n\r\n递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试`fact(1000)`：\r\n\r\n```\r\n>>> fact(1000)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"<stdin>\", line 4, in fact\r\n  ...\r\n  File \"<stdin>\", line 4, in fact\r\nRuntimeError: maximum recursion depth exceeded in comparison\r\n```\r\n\r\n优化递归调用栈溢出的方法是通过**尾递归**，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。\r\n尾递归是指：在函数返回的时候，调用自身本身，并且return语句不能包含表达式。上面的`fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归。实现尾递归方式，主要是要把每一步的乘积传入到递归函数中：\r\n\r\n```\r\ndef fact(n):\r\n    return fact_iter(n, 1)\r\n\r\ndef fact_iter(num, product):\r\n    if num == 1:\r\n        return product\r\n    return fact_iter(num - 1, num * product)\r\n```\r\n\r\n> 注：Python中尾递归不能解决递归的栈溢出问题\r\n\r\n\r\n',1,'post','publish','Python','Python学习笔记',88,0,1,1,1),(18,'第七章 模块',NULL,1515500840,1517153747,'# 模块\r\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里。在Python中一个.py文件就称为一个模块。编写模块的优点：\r\n\r\n* 大大提高代码的可维护性 \r\n* 一个模块编写完毕，可以被其他模块引用\r\n* 使用模块还可以避免函数名和变量名冲突，相同的函数名以及变量名可以放在不同的模块当中。\r\n> 为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）',1,'post','publish','Python','Python学习笔记',15,0,1,1,1),(19,'第一章 Bean的生命周期',NULL,1515501215,1515501215,'# Bean的生命周期\r\n\r\n1. 定义\r\n2. 初始化\r\n3. 使用\r\n4. 销毁\r\n\r\n## 初始化\r\n\r\n* 默认配置bean初始化 - 针对所有bean\r\n* 单独配置bean初始化 - 针对单个bean\r\n* 实现接口 - 针对单个bean\r\n\r\n\r\n\r\n### 默认配置bean初始化\r\n\r\n1. 在spring配置文件中,beans文件头中配置 default-init-method=\"init\" default-destory-method=\"destory\"\r\n2. default-init-method与default-destory-method的属性值与class中的启动方法名**必须**一一对应，但是可以不用配置\r\n\r\n```\r\n<bean id=\"initBean\" class=\"com.yaodao.BeanDemo\"/>\r\n```\r\n\r\n### 单独配置bean初始化\r\n\r\n1. 在spring配置文件中,加上init-method属性\r\n2. init-method的属性值与class中的启动方法名**必须**一一对应\r\n\r\n```\r\n<bean id=\"initBean\" class=\"com.yaodao.BeanDemo\" init-method=\"start\" />\r\n```\r\n\r\n### 实现接口配置bean初始化\r\n\r\n1. 实现org.springframework.beans.factory.InitializingBean接口覆盖afterPropertiesSet方法配置bean的启动\r\n2. 实现org.springframework.beans.factory.DisposableBean接口覆盖destory方法配置bean的销毁\r\n\r\n## 区别与执行顺序\r\n\r\n* 当三种初始化方式同时存在时，先执行接口实现的方式，再执行单个配置bean初始化的方式，且不执行默认配置方式\r\n* 单个bean配置方式中的init与destory的属性值，必须与对应的class中的初始化方法名称一一对应，**且必须配置**；默认配置方式也必须一一对应，**但是可以不用配置**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Spring','Spring学习笔记',9,0,1,1,1),(20,'浅析JAVA类加载器',NULL,1515501567,1515548356,'\r\n## 类加载器与类的唯一性\r\n\r\n类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的**唯一性**。通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。\r\n这里的“相等”，包括代表类的Class对象的equals\\(\\)方法、isAssignableFrom\\(\\)方法、isInstance\\(\\)方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。\r\n以下代码说明了不同的类加载器对instanceof关键字运算的结果的影响。\r\n\r\n```\r\npackage com.jvm.classloading;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n/**\r\n * 类加载器在类相等判断中的影响\r\n * instanceof关键字\r\n */\r\npublic class ClassLoaderTest {\r\n    public static void main(String[] args) throws Exception {\r\n        // 自定义类加载器\r\n        ClassLoader myLoader = new ClassLoader() {\r\n            @Override\r\n            public Class<?> loadClass(String name) throws ClassNotFoundException {\r\n                try {\r\n                    String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\r\n                    InputStream is = getClass().getResourceAsStream(fileName);\r\n                    if (is == null) {\r\n                        return super.loadClass(fileName);\r\n                    }\r\n                    byte[] b = new byte[is.available()];\r\n                    is.read(b);\r\n                    return defineClass(name, b, 0, b.length);   \r\n                } catch (IOException e) {\r\n                    throw new ClassNotFoundException();\r\n                }\r\n            }\r\n        };\r\n        // 使用ClassLoaderTest的类加载器加载本类\r\n        Object obj1 = ClassLoaderTest.class.getClassLoader().loadClass(\"com.jvm.classloading.ClassLoaderTest\").newInstance();\r\n        System.out.println(obj1.getClass());\r\n        System.out.println(obj1 instanceof com.jvm.classloading.ClassLoaderTest);\r\n        // 使用自定义类加载器加载本类\r\n        Object obj2 = myLoader.loadClass(\"com.jvm.classloading.ClassLoaderTest\").newInstance();\r\n        System.out.println(obj2.getClass());\r\n        System.out.println(obj2 instanceof com.jvm.classloading.ClassLoaderTest);\r\n    }\r\n}\r\n```\r\n结果：\r\n```\r\nclass com.jvm.classloading.ClassLoaderTest\r\ntrue\r\nclass com.jvm.classloading.ClassLoaderTest\r\nfalse\r\n```\r\n\r\n## 类加载器种类\r\n从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。\r\n从开发者的角度，类加载器可以细分为：\r\n\r\n* 启动（Bootstrap）类加载器：负责将 Java\\_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。\r\n\r\n* 标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java\\_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。\r\n\r\n* 应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader\\(\\)方法的返回值，因此一般称为**系统（System）加载器**。\r\n\r\n除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的**双亲委派模型**。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过**组合（Composition）关系**来实现，而不是通过继承（Inheritance）。\r\n\r\n![](/assets/import.png)\r\n\r\n## 双亲委派模型\r\n### 双亲委派模型过程\r\n\r\n某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。\r\n使用双亲委派模型的好处在于**Java类随着它的类加载器一起具备了一种带有优先级的层次关系**。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。\r\n### 双亲委派模型的系统实现\r\n\r\n在java.lang.ClassLoader的loadClass\\(\\)方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass\\(\\)方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass\\(\\)方法进行加载。\r\n\r\n```\r\nprotected synchronized Class<?> loadClass(String name,boolean resolve)throws ClassNotFoundException{\r\n    //check the class has been loaded or not\r\n    Class c = findLoadedClass(name);\r\n    if(c == null){\r\n        try{\r\n            if(parent != null){\r\n                c = parent.loadClass(name,false);\r\n            }else{\r\n                c = findBootstrapClassOrNull(name);\r\n            }\r\n        }catch(ClassNotFoundException e){\r\n            //if throws the exception ,the father can not complete the load\r\n        }\r\n        if(c == null){\r\n            c = findClass(name);\r\n        }\r\n    }\r\n    if(resolve){\r\n        resolveClass(c);\r\n    }\r\n    return c;\r\n}\r\n```\r\n\r\n注意，双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现，具体分析可以参见周志明著《深入理解Java虚拟机》。\r\n\r\n',1,'post','publish','Java','Java基础',33,0,1,1,1),(21,'第一章 深入Web请求过程',NULL,1515942859,1515988114,'# 如何发起一个HTTP请求\r\n* 浏览器\r\n* 因为发起一个HTTP请求的过程就是建立一个socket通信的过程，因此可以使用实现了HTTP请求的工具包\r\n* Linux的curl命令，`curl \"www.baidu.com\"`，可以使用`curl -I \"www.baidu.com\"`查看HTTP请求头\r\n# 浏览器缓存\r\n* HTTP header中的Cache-Control\r\n* HTTP header中的Pragma\r\n# DNS域名解析\r\n## 域名解析过程\r\n### 浏览器缓存\r\n* 如果缓存时间设置过长，当域名与IP映射发生变化，将不能即时更新到最新IP地址，从而导致该域名不能被正常解析\r\n* 如果缓存时间设置过短，将导致客户端每次访问都要重新解析一遍域名\r\n### 本地域名解析\r\nlinux中本地域名配置文件保存在/etc/hosts，但是最好设置成只读文件，防止轻易被修改造成域名劫持\r\n### DNS服务器\r\n指定到运营提供的DNS服务器，即LDNS，如果还未命中就直接到Root Server，...，这里暂时省略\r\n## 跟踪域名解析过程 \r\n命令：`nslookup`或`dig www.baidu.com`\r\n## 清除缓存域名\r\n* Windows下，`ipconfig /flushdns`\r\n* Linux下，`/etc/init.d/nscd restart`\r\n## JVM缓存DNS\r\n此缓存在InetAddress类中，有两种缓存策略：\r\n* 正确解析结果\r\n* 失败解析结果\r\n这两个缓存时间由`%JAVA_HOME%\\lib\\security\\java.security`中的`networkaddress.cache.ttl`和`networkaddress.cache.negative.ttl`控制，默认值分别是-1(永不失效)和10(缓存10秒)\r\n\r\n如何修改：\r\n* 直接修改java.security文件中的默认值\r\n* 在Java的启动参数中增加-Dsun.net.inetaddr.ttl=xxx修改默认值\r\n* 通过InetAddress类动态修改，但必须是单例模式，不然会有严重的性能问题\r\n\r\n\r\n\r\n',1,'post','publish','Java,JavaWeb','JavaWeb技术内幕',26,0,1,1,1),(22,'JDBC简单示例',NULL,1516003784,1516003784,'通过java.sql中的Connection、PreparedStatement、ResultSet简单来做JDBC的连接、查询、数据获取\r\n```\r\nimport org.junit.Test;\r\nimport java.sql.*;\r\n\r\npublic class TestJDBC {\r\n    private Connection connection = null;\r\n    private ResultSet resultSet = null;\r\n\r\n    @Test\r\n    public void testUser() {\r\n        checkJdbc(\"qcxiao\", \"123456\");\r\n    }\r\n\r\n\r\n    public boolean checkJdbc(String username, String password) {\r\n        try {\r\n            //注入数据库连接驱动\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n            try {\r\n                //获取数据库连接对象\r\n                connection = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1/myblog\", \"root\", \"123456\");\r\n                //构建sql语句，?代表需要替换的参数\r\n                String sql = \"select * from t_user where username=? and password=?\";\r\n                //获取PreparedStatement对象\r\n                PreparedStatement preparedStatement = connection.prepareStatement(sql);\r\n                //绑定参数\r\n                preparedStatement.setString(1, username);\r\n                preparedStatement.setString(2, password);\r\n                //执行sql语句，这里是查询语句，所以调用executeQuery返回结果集\r\n                resultSet = preparedStatement.executeQuery();\r\n                // 通过获取到的数据库结果做验证\r\n                if (resultSet.next()) {\r\n                    //结果集不为空，则可以表示用户存在，测试成功\r\n                    System.out.println(resultSet.getObject(\"email\"));\r\n                    resultSet.close();\r\n                    connection.close();\r\n                    return true;\r\n                }\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```',1,'post','publish','Java,Mysql,JDBC','Java基础',19,0,1,1,1),(23,'MyBatis+SpringBoot简单应用',NULL,1516013087,1516014311,'# MyBatis+SpringBoot介绍\r\nMyBatis在SpringBoot基础上开发了`mybatis-spring-boot-starter`一套解决方案，可以通过两种方式：\r\n\r\n* 全部基于注解\r\n* 依然通过xml配置，不过较以前简化了很多\r\n都需要在pom.xml中引入`mybatis-spring-boot-starter`\r\n```\r\n<dependency>\r\n	<groupId>org.mybatis.spring.boot</groupId>\r\n	<artifactId>mybatis-spring-boot-starter</artifactId>\r\n	<version>1.1.1</version>\r\n</dependency>\r\n<dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n</dependency>\r\n```\r\n# 必要配置\r\n## `application.properties`配置\r\n```\r\nmybatis.type-aliases-package = top.qcxiao.blog\r\nspring.datasource.driverClassName = com.mysql.jdbc.Driver\r\nspring.datasource.url = jdbc:mysql://localhost:3306/myblog?useSSL=false&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&autoReconnect=true\r\nspring.datasource.username = root\r\nspring.datasource.password = 123456\r\nmybatis.config-locations=classpath:mybatis/mybatis-config.xml\r\nmybatis.mapper-locations=classpath:mybatis/mapper/*.xml\r\n```\r\n此时SpringBoot会自动加载spring.datasource.*相关配置，数据源就会自动注入到sqlSessionFactory中，sqlSessionFactory会自动注入到Mapper中\r\n## 在启动类中添加对mapper包扫描`@MapperScan`\r\n```\r\n@SpringBootApplication\r\n@MapperScan(\"top.qcxiao.blog.dao\")\r\npublic class Application {\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(Application.class, args);\r\n	}\r\n}\r\n```\r\n# 全注解版\r\n```\r\npublic interface UserMapper {\r\n	\r\n	@Select(\"SELECT * FROM t_user\")\r\n	@Results({\r\n		@Result(property = \"username\",  column = \"username\", javaType = String),\r\n		@Result(property = \"nickName\", column = \"nick_name\")\r\n                ......\r\n	})\r\n	List<UserEntity> getAll();\r\n}\r\n```\r\n* @Select 是查询类的注解，所有的查询均使用这个\r\n* @Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。\r\n* @Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值\r\n* @Update 负责修改，也可以直接传入对象\r\n* @delete 负责删除\r\n\r\n使用时，可以直接调用getAll方法就可以使用了;我不太喜欢这种方式，原因是当遇到一些复杂逻辑时不能直观的通过SQL来观察，因此我一般使用下面一种方式，即xml配置版\r\n# xml配置版\r\n## 增加`application.properties`的配置\r\n```\r\nmybatis.config-locations=classpath:mybatis/mybatis-config.xml\r\nmybatis.mapper-locations=classpath:mybatis/mapper/*.xml\r\n```\r\n用以指定mybatis基础配置文件和实体类映射文件的地址\r\n## `mybatis-config.xml` 配置\r\n```\r\n<configuration>\r\n    <typeAliases>\r\n        <typeAlias alias=\"Integer\" type=\"java.lang.Integer\"/>\r\n        <typeAlias alias=\"Long\" type=\"java.lang.Long\"/>\r\n        <typeAlias alias=\"HashMap\" type=\"java.util.HashMap\"/>\r\n        <typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\"/>\r\n        <typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\"/>\r\n        <typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\"/>\r\n        <typeAlias alias=\"User\" type=\"top.qcxiao.blog.entity.User\"/>\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n## 增加实体类映射文件`UserMapper.xml`\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"top.qcxiao.blog.dao.UserMapper\" >\r\n    <resultMap id=\"BaseResultMap\" type=\"User\" >\r\n        <id column=\"uid\" property=\"uid\" jdbcType=\"INTEGER\" />\r\n        <result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\" />\r\n        <result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\" />\r\n        <result column=\"email\" property=\"email\" jdbcType=\"VARCHAR\"/>\r\n        <result column=\"home_url\" property=\"homeUrl\" jdbcType=\"VARCHAR\"/>\r\n        <result column=\"nick_name\" property=\"nickName\" jdbcType=\"VARCHAR\" />\r\n        <result column=\"group_name\" property=\"groupName\" jdbcType=\"VARCHAR\" />\r\n        <result column=\"created\" property=\"created\" jdbcType=\"INTEGER\" />\r\n        <result column=\"end_activated\" property=\"endActivated\" jdbcType=\"INTEGER\" />\r\n        <result column=\"end_logined\" property=\"endLogined\" jdbcType=\"INTEGER\" />\r\n    </resultMap>\r\n\r\n    <sql id=\"Base_Column_List\" >\r\n        uid, username, password, email, home_url,nick_name,group_name,created,end_activated,end_logined\r\n    </sql>\r\n\r\n    <select id=\"getAll\" resultMap=\"BaseResultMap\"  >\r\n        SELECT\r\n        <include refid=\"Base_Column_List\" />\r\n        FROM t_user\r\n    </select>\r\n\r\n    <select id=\"get\" parameterType=\"java.lang.Integer\" resultMap=\"BaseResultMap\" >\r\n        SELECT\r\n        <include refid=\"Base_Column_List\" />\r\n        FROM t_user\r\n        WHERE uid = #{uid}\r\n    </select>\r\n\r\n    <insert id=\"insert\" parameterType=\"top.qcxiao.blog.entity.User\" >\r\n        INSERT INTO\r\n        t_user\r\n        (username, password, email, home_url,nick_name,group_name,created,end_activated,end_logined)\r\n        VALUES\r\n        (#{username}, #{password}, #{email}, #{homeUrl}, #{nickName}, #{groupName}, #{created}, #{endActivated}, #{endLogined})\r\n    </insert>\r\n\r\n    <update id=\"update\" parameterType=\"top.qcxiao.blog.entity.User\" >\r\n        UPDATE\r\n        t_user\r\n        SET\r\n        <if test=\"username != null\">username = #{username},</if>\r\n        <if test=\"password != null\">password = #{password},</if>\r\n        WHERE\r\n        uid = #{uid}\r\n    </update>\r\n\r\n    <delete id=\"delete\" parameterType=\"java.lang.Integer\" >\r\n        DELETE FROM\r\n        t_user\r\n        WHERE\r\n        uid =#{uid}\r\n    </delete>\r\n</mapper>\r\n```\r\n## 编写各层代码\r\n```\r\n// Dao层\r\n@Repository\r\npublic interface UserMapper {\r\n    List<User> getAll();\r\n    User get(Integer uid);\r\n    void insert(User user);\r\n    void update(User user);\r\n    void delete(Integer uid);\r\n}\r\n// service层\r\npublic interface UserService {\r\n    List<User> getAll();\r\n    User get(Integer uid);\r\n    void insert(User user);\r\n    void update(User user);\r\n    void delete(Integer uid);\r\n}\r\n@Service\r\npublic class UserServiceImpl implements UserService {\r\n\r\n    @Autowired\r\n    public UserMapper userMapper;\r\n\r\n    @Override\r\n    public List<User> getAll() {\r\n        return userMapper.getAll();\r\n    }\r\n\r\n    @Override\r\n    public User get(Integer uid) {\r\n        return userMapper.get(uid);\r\n    }\r\n\r\n    @Override\r\n    public void insert(User user) {\r\n        userMapper.insert(user);\r\n    }\r\n\r\n    @Override\r\n    public void update(User user) {\r\n        userMapper.update(user);\r\n    }\r\n\r\n    @Override\r\n    public void delete(Integer uid) {\r\n        userMapper.delete(uid);\r\n    }\r\n}\r\n// controller层\r\n@RestController\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    public UserService userService;\r\n\r\n    @RequestMapping(\"getUsers\")\r\n    //自动根据方法生成缓存\r\n    @Cacheable(value=\"users\")\r\n    public List<User> getUsers(){\r\n        System.out.println(\"未命中redis缓存\");\r\n        List<User> users = userService.getAll();\r\n        return users;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','MyBatis,SpringBoot','MyBatis,SpringBoot',23,0,1,1,1),(24,'SpringBoot+RabbitMQ应用',NULL,1516024229,1516025368,'# RabbitMQ安装\r\n由于不想安装环境，这里我使用Docker来安装RabbitMQ\r\n`docker run -d -e RABBITMQ_NODENAME=rabbit --name rabbit -p 25672:15672 rabbitmq:3-management`\r\nrabbitmq:3-management有管理页面，开放端口为15672，server端口为5672\r\n`docker exec -it f53a2ffed2a3 /bin/bash`\r\n# RabbitMQ操作\r\n`http://blog.51cto.com/296853913/976252`\r\n# 关联SpringBoot\r\n## 添加依赖\r\n```\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-starter-amqp</artifactId>\r\n</dependency>\r\n```\r\n## 配置连接\r\n```\r\n# RabbitMQ配置\r\nspring.application.name=spirng-boot-rabbitmq-sender\r\nspring.rabbitmq.host=localhost\r\nspring.rabbitmq.port=25672\r\nspring.rabbitmq.username=guest\r\nspring.rabbitmq.password=guest\r\nspring.rabbitmq.publisher-confirms=true\r\nspring.rabbitmq.virtual-host=/\r\n```\r\n## 消息队列配置\r\n```\r\n/**\r\n * 消息队列配置\r\n */\r\n@Configuration\r\npublic class RabbitConfig {\r\n    @Bean\r\n    public Queue Queue() {\r\n        return new Queue(\"hello\");\r\n    }\r\n\r\n}\r\n```\r\n指定关联键为hello\r\n## 接收者\r\n```\r\n@Component\r\npublic class Receiver {\r\n    @RabbitListener(queues = \"hello\")//queue name必须和发送者保持一致\r\n    @RabbitHandler\r\n    public void process(String hello) {\r\n        System.out.println(\"接收消息1  : \" + hello);\r\n    }\r\n}\r\n```\r\n## 发送者\r\n```\r\n/**\r\n * 发送者\r\n * rabbitTemplate是springboot 提供的默认实现\r\n */\r\n@Component\r\npublic class Sender {\r\n    @Autowired\r\n    private AmqpTemplate rabbitTemplate;\r\n\r\n    public void send() {\r\n        String context = \"hello \" + new Date();\r\n        System.out.println(\"发送消息 : \" + context);\r\n        this.rabbitTemplate.convertAndSend(\"hello\", context);\r\n    }\r\n\r\n}\r\n```\r\n## 测试\r\n```\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class RabbitMqTest {\r\n\r\n    @Autowired\r\n    private Sender sender;\r\n\r\n    @Test\r\n    public void test() throws Exception {\r\n        sender.send();\r\n    }\r\n}\r\n```\r\n# 多对多发送\r\n```\r\n@Test\r\npublic void test() throws Exception {\r\n    for (int i = 0; i < 100; i++) {\r\n          sender.send(i);\r\n    }\r\n}\r\n```\r\n一个发送者，多个接受者,经过测试会均匀的将消息发送到N个接收者中；多个发送者，多个接受者，也是一样的。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','RabbitMQ,SpringBoot','SpringBoot',40,0,1,1,1),(25,'第一章 在列表、字典、集合中根据条件过滤筛选数据',NULL,1516203438,1516205496,'# 过滤一个列表中的负数\r\n## filter函数过滤\r\n```\r\n# 引入randint函数，生成10个从-10到10由数字构成的列表\r\nfrom random import randint\r\ndata = [randint(-10,10) for _ in xrange(10)]\r\n# 通过filter函数过滤负数，同时lambda匿名函数的作用是:后的判断为真时:前的参数就会进入最终的结果\r\nfilter(lambda x:x>=0,data)\r\n```\r\n## 列表解析过滤\r\n`[x for x in data if x >= 0]`\r\n\r\n## 两种过滤方式效率比较\r\n```\r\nIn [10]: timeit filter(lambda x:x>=0,data)\r\n100000 loops, best of 3: 2.16 µs per loop\r\n\r\nIn [11]: timeit [x for x in data if x >= 0]\r\n100000 loops, best of 3: 2.03 µs per loop\r\n```\r\n经比较，列表解析的效率会高于filter\r\n# 筛选字典中小于60的项\r\n```\r\n# 构造字典\r\nIn [12]: d = {x:randint(1,100) for x in xrange(1,20)}\r\n\r\nIn [13]: d\r\nOut[13]: \r\n{1: 55,\r\n 2: 32,\r\n 3: 3,\r\n 4: 32,\r\n 5: 89,\r\n 6: 12,\r\n 7: 29,\r\n 8: 19,\r\n 9: 5,\r\n 10: 95,\r\n 11: 61,\r\n 12: 75,\r\n 13: 69,\r\n 14: 80,\r\n 15: 84,\r\n 16: 37,\r\n 17: 67,\r\n 18: 10,\r\n 19: 1}\r\n# 通过字典解析筛选出小于60的项\r\nIn [18]: {k:v for k,v in d.iteritems() if v < 60}\r\nOut[18]: {1: 55, 2: 32, 3: 3, 4: 32, 6: 12, 7: 29, 8: 19, 9: 5, 16: 37, 18: 10, 19: 1}\r\n```\r\n# 筛选出集合中能被3整除的项\r\n```\r\n# 将上述的data转成集合\r\nIn [19]: s = set(data)\r\nIn [20]: s\r\nOut[20]: {-7, -4, -2, 0, 2, 5, 8}\r\n# 通过集合解析器筛选出被3整除的项\r\nIn [21]: {x for x in s if x % 3 == 0}\r\nOut[21]: {0}\r\n\r\n# 通过集合解析器筛选出被2整除的项\r\nIn [22]: {x for x in s if x % 2 == 0}\r\nOut[22]: {-4, -2, 0, 2, 8}\r\n```\r\n\r\n\r\n',1,'post','publish','Python','Python进阶',29,0,1,1,1),(26,'2018任务',NULL,1516246327,1518350291,'# 积累\r\n* 链路回放，sandbox、龙珠\r\n* 抓包\r\n* 弱网\r\n* 埋点\r\n* 端上性能\r\n* 端上自动化\r\n# 系统学习\r\n* Python语言，程度：熟练网站开发、爬虫、入门机器学习\r\n* Java相关，程度：精通JVM机关机制、web开发原理、多线程、熟悉类加载机制\r\n* Spring相关，程度：熟悉Spring机制，掌握SpringBoot、SpringCloud\r\n* 中间件，程度：掌握流行中间件，如：Dubbo、hsf\r\n* 分布式、缓存\r\n    * tair，http://www.infoq.com/cn/articles/taobao-tair\r\n    * hbase，https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-hbase/index.html\r\n* 算法，程度：掌握基本的算法；朴素贝叶斯、支持向量机、感知器、决策树\r\n* Linux，程度：掌握基本指令，熟悉性能工具\r\n* Docker，程度：掌握Docker相关操作\r\n* 通信协议\r\n* Socket\r\n    * Socket是进程通讯的一种方式，即调用这个网络库的一些API函数实现分布在不同主机的相关进程之间的数据交换。\r\n\r\n\r\n# 学习资源\r\n## Python\r\n* 数据结构：http://interactivepython.org/courselib/static/pythonds/index.html\r\n\r\n## 通信协议\r\n* http://www.cnblogs.com/xhwy/archive/2012/03/03/2378293.html\r\n',1,'post','publish','积累','默认分类',19,0,1,1,1),(28,'Python2.7和Python3.0的语法差异',NULL,1516864876,1517072420,'# 基本语法\r\n## python3默认编码\r\nPython2 的默认编码是 ascii，这也是导致 Python2 中经常遇到编码问题的原因之一，至于是为什么会使用 asscii 作为默认编码，原因在于 Python这门语言诞生的时候还没出现 Unicode。Python 3 默认采用了 UTF-8 作为默认编码，因此你不再需要在文件顶部写 # coding=utf-8 了。\r\n## 迭代器\r\n在 Python2 中很多返回列表对象的内置函数和方法在 Python 3 都改成了返回类似于迭代器的对象，因为迭代器的惰性加载特性使得操作大数据更有效率。Python2 中的 range 和 xrange 函数合并成了 range，如果同时兼容2和3，可以这样。\r\n另外，字典对象的 dict.keys()、dict.values() 方法都不再返回列表，而是以一个类似迭代器的 \"view\" 对象返回。高阶函数 map、filter、zip 返回的也都不是列表对象了。Python2的迭代器必须实现 next 方法，而 Python3 改成了 next\r\n\r\n## print不再是语句，而是函数\r\n比如原来是 print \'abc\' 现在是 print(\'abc\')\r\n但是 python2.6+ 可以使用 from future import print_function 来实现相同功能。\r\n\r\n## 原来1/2（两个整数相除）结果是0，现在是0.5了\r\n```\r\n$ /opt/python3.6/bin/python3\r\nPython 3.6.2 (default, Aug 4 2017, 10:27:08)\r\n[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> 1/2\r\n0.5\r\n>>> 1/3\r\n0.3333333333333333\r\n```\r\n## 新的字符串格式化方法format取代%\r\n\r\n## python3 彻底废弃了 long+int\r\n统一为 int , 支持高精度整数运算\r\n## Python2中用raw_input ,Python3中用input\r\n\r\n# 数据类型\r\n## 字符串\r\n字符串是最大的变化之一，这个变化使得编码问题降到了最低可能。在 Python2 中，字符串有两个类型，一个是 unicode，一个是 str，前者表示文本字符串，后者表示字节序列，不过两者并没有明显的界限，开发者也感觉很混乱，不明白编码错误的原因，不过在 Python3 中两者做了严格区分，分别用 str 表示字符串，byte 表示字节序列，任何需要写入文本或者网络传输的数据都只接收字节序列，这就从源头上阻止了编码错误的问题。\r\n一言以蔽之，请看下图中Python2中的str与unicode各对应Python3中的类型：\r\n<table width=70%>\r\n  <tr>\r\n    <th width=50%, bgcolor=yellow>Python2</th>\r\n    <th width=\"50%\", bgcolor=yellow>Python3</th>\r\n  </tr>\r\n  <tr>\r\n    <td> str，只能通过ascii编码，一个字符就是一个字节如：\'abcdefg1\'，即只能是英文和数字且不是真正含义的字符串</td>\r\n    <td> bytes </td>\r\n  </tr>\r\n  <tr>\r\n    <td> unicode，兼容UTF8、GBK等，才是真正含义的字符串</td>\r\n    <td> str</td>\r\n</table>\r\n\r\n## 文件编码\r\n* Python2，不能直接将unicode存入文件；写入文件时对unicode编码，读文件时需要对二进制字符串解码；因此存入文件的不能是unicode而是对unicode编码后的str\r\n* Python3，open函数指定\'t\'的文件模式，endcoding指定编码格式来自动编解码\r\n# 模块化编程\r\n## 增加了一些新模块\r\nconcurrent.futures、venv、unittest.mock、asyncio、selectors、typing\r\n## 去掉了一些模块或者函数\r\ngopherlib、md5、contextlib.nested、inspect.getmoduleinfo等。\r\n去掉的内容的原因主要是2点：\r\n\r\n - 过时的技术产物，已经没什么人在用了；\r\n - 出现了新的替代产物后者被证明存在意义不大。理论上对于开发者影响很小。 \r\n## 模块名称修改\r\n把一些相关的模块合并到同一个包里面，如：\r\n如httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib放进了http里面。\r\nurllib, urllib2, urlparse, robotparse放进了urllib里面。\r\nSocketServer模块名改成了socketserver，Queue模块名改成queue\r\n\r\n\r\n说明：非原创\r\n来源：https://www.imooc.com/article/22732',1,'post','publish','Python','Python',79,0,1,1,1),(29,'第一章 Linux基础指令入门',NULL,1516949769,1516982093,'# 获取当前host与账户\r\n```\r\nroot@docker-qcxiao:/# hostname\r\ndocker-qcxiao\r\nroot@docker-qcxiao:/# whoami\r\nroot\r\n```\r\n# 长参数与短参数\r\n## 短参数\r\n格式：-params\r\n短参数可以单独使用，也可以合并使用，如：\r\n```\r\nroot@docker-qcxiao:/Users# ls -l -a\r\ntotal 12\r\ndrwxr-xr-x 3 root root 4096 Jan 26 03:39 .\r\ndrwxr-xr-x 1 root root 4096 Jan 26 06:29 ..\r\ndrwxr-xr-x 3 root root 4096 Jan 26 03:39 qcxiao\r\nroot@docker-qcxiao:/Users# ls -la\r\ntotal 12\r\ndrwxr-xr-x 3 root root 4096 Jan 26 03:39 .\r\ndrwxr-xr-x 1 root root 4096 Jan 26 06:29 ..\r\ndrwxr-xr-x 3 root root 4096 Jan 26 03:39 qcxiao\r\n```\r\n## 长参数\r\n格式：--param，为什么是两个-而不是一个呢，思考一下短参数的合并\r\n长参数只能单独使用，不能合并使用，当然可以和短参数联合使用\r\n\r\n## 参数赋值\r\n`-param = 10`\r\n\r\n# 翻页、翻行\r\n* 空格翻页\r\n* 回车键查找下一行\r\n# 命令的历史记录\r\n* 上下键切换\r\n* CTRL+R快捷键进一步精确查找历史命令\r\n* history可以查看所有历史命令\r\n# 一些实用的快捷键\r\n* Ctrl + L，与clear一致\r\n长命令操作：\r\n* Ctrl + A 光标跳到一行命令的开头\r\n* Ctrl + E 光标跳到一行命令的结尾\r\n* Ctrl + U 删除所有在光标左侧的命令字符\r\n* Ctrl + K 删除所有在光标右侧的命令字符\r\n* Ctrl + W 删除光标左侧的一个“单词”\r\n* Ctrl + Y 粘贴用Ctrl + U， Ctrl + K或Ctrl + W“删除”的字符串，有点像“剪切-粘贴”\r\n\r\n# ls\r\n## -A与-a异同\r\n* 相同：都会显示所有文件，包括隐藏文件\r\n* 不同：不显示.和..的文件\r\n## -h\r\n当我们仅用ls -l时，列出的文件详细信息中，文件的大小是以字节为单位的。有时这不是太直观。\r\n可以再加一个参数-h，h是humain readable的缩写，表示“适合人类阅读的”。所以我们的命令变成了：`ls -lh`\r\n```\r\nroot@docker-qcxiao:/# ls -lh\r\ntotal 72K\r\n-rw-r--r--   1 root root    2 Jan 26 06:29 1.txt\r\ndrwxr-xr-x   3 root root 4.0K Jan 26 03:39 Users\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 bin\r\ndrwxr-xr-x   2 root root 4.0K Apr 12  2016 boot\r\ndrwxr-xr-x   5 root root  360 Jan 26 03:39 dev\r\ndrwxr-xr-x   1 root root 4.0K Jan 26 03:39 etc\r\ndrwxr-xr-x   2 root root 4.0K Apr 12  2016 home\r\ndrwxr-xr-x   8 root root 4.0K Sep 13  2015 lib\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 lib64\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 media\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 mnt\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 opt\r\ndr-xr-xr-x 157 root root    0 Jan 26 03:39 proc\r\ndrwx------   1 root root 4.0K Jan 26 07:12 root\r\ndrwxr-xr-x   1 root root 4.0K Jan 23 22:49 run\r\ndrwxr-xr-x   1 root root 4.0K Jan 25 18:23 sbin\r\ndrwxr-xr-x   2 root root 4.0K Jan 23 22:49 srv\r\ndr-xr-xr-x  13 root root    0 Jan 26 03:13 sys\r\ndrwxrwxrwt   2 root root 4.0K Jan 23 22:49 tmp\r\ndrwxr-xr-x   1 root root 4.0K Jan 23 22:49 usr\r\ndrwxr-xr-x   1 root root 4.0K Jan 23 22:49 var\r\n```\r\n## -t\r\n按文件最近一次修改时间排序\r\n`ls -lt`\r\n\r\n# less\r\n记住h参数即可\r\n\r\n\r\n',1,'post','publish','Linux','Linux基础探索系列',29,0,1,1,1),(30,'第五章 Python高级特性',NULL,1517155489,1517216349,'# 切片\r\n* Python中的切片，可以理解成其它语言的字符串截取，但是比很多语言都简明\r\n* 切片可操作的对象一定是可迭代对象，比如List、tuple、str、unicode\r\n## 切片的使用\r\n```\r\nIn [12]: l = range(100)\r\nIn [13]: l[::10]\r\nOut[13]: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\r\n```\r\n示例：`L[start:stop:step]`\r\n\r\n> 说明：start 和 stop 是列表下标，包含 start 下标的元素，不包含 stop 下标的元素，step 是步进，即每次取元素的步长，默认值是1\r\n# 迭代\r\n只要是可迭代对象就可以做迭代操作。如何判断是否是可迭代对象？\r\n```\r\nIn [20]: from collections import Iterable\r\nIn [21]: isinstance(\"abc\", Iterable)\r\nOut[21]: True\r\nIn [22]: isinstance([1,2,3], Iterable)\r\nOut[22]: True\r\nIn [23]: isinstance((1,2,3), Iterable)\r\nOut[23]: True\r\nIn [24]: isinstance({\'a\':1}, Iterable)\r\nOut[24]: True\r\nIn [25]: isinstance(set([\'a\',\'b\']), Iterable)\r\nOut[25]: True\r\nIn [26]: isinstance(u\'哈哈\', Iterable)\r\nOut[26]: True\r\nIn [27]: isinstance(1, Iterable)\r\nOut[27]: False\r\n```\r\n从以上测试来看，unicode、str、list、dict、tuple、set都是可迭代对象，因此都可以进行迭代，而其它数据类型不行\r\n\r\n## 迭代dict\r\n默认情况下，迭代dict只是迭代其key，如下：\r\n```\r\nIn [28]: d = {\'a\': 1, \'b\': 2, \'c\': 3}\r\nIn [29]: for x in d:\r\n    ...:     print x\r\n    ...:\r\na\r\nc\r\nb\r\n```\r\n如果想要迭代其value：`for value in d.itervalues()`，如果要同时迭代key和value，可以用`for k, v in d.iteritems()`\r\n## 迭代下标\r\n如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：\r\n```\r\nIn [39]: for i, value in enumerate([\'A\', \'B\', \'C\']):\r\n    ...: ...     print i, value\r\n    ...:\r\n0 A\r\n1 B\r\n2 C\r\n```\r\n# 列表生成式\r\n* 生成的结果是列表list\r\n* 列表生成式前可以有计算表达式\r\n\r\n```\r\nIn [68]: [x*x for x in range(1,10)]\r\nOut[68]: [1, 4, 9, 16, 25, 36, 49, 64, 81]\r\nIn [69]: [x*x for x in range(1,10) if x % 2 == 0]\r\nOut[69]: [4, 16, 36, 64]\r\nIn [70]: [x+y for x in \'123\' for y in \'abc\']\r\nOut[70]: [\'1a\', \'1b\', \'1c\', \'2a\', \'2b\', \'2c\', \'3a\', \'3b\', \'3c\']\r\n```\r\n应用：列出当前目录下的所有文件和目录名\r\n```\r\nIn [74]: import os\r\nIn [76]: [x for x in os.listdir(\'/Users/qcxiao/Python\')]\r\nOut[76]: [\'1.py\', \'1.txt\']\r\n```\r\n## 复杂应用\r\n```\r\nIn [82]: L = [\'Hello\', \'World\', 18, \'Apple\', None]\r\nIn [83]: [s.lower() if isinstance(s, str) else s for s in L]\r\nOut[83]: [\'hello\', \'world\', 18, \'apple\', None]\r\n```\r\n\r\n# 生成器\r\n在Python中，这种一边循环一边计算的机制，称为生成器（Generator）\r\n## 创建生成器\r\n将列表生成式的[]改为()\r\n```\r\nIn [99]: g = (x * x for x in range(10))\r\nIn [100]: g\r\nOut[100]: <generator object <genexpr> at 0x1049f8eb0>\r\n```\r\n## 获取元素\r\n### next()方法获取\r\n获取生成器元素可以通过next()方法一一获取，但是较为麻烦，看下面的方法\r\n### 迭代获取\r\n```\r\nIn [103]: g = (x * x for x in range(10))\r\nIn [104]: from collections import Iterable\r\nIn [105]: isinstance(g, Iterable)\r\nOut[105]: True\r\n```\r\n以上我们得出，生成器也是可迭代对象\r\n```\r\nIn [106]: for x in g:\r\n     ...:     print x\r\n     ...:\r\n0\r\n1\r\n4\r\n9\r\n16\r\n25\r\n36\r\n49\r\n64\r\n81\r\n```\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Python','Python学习笔记',28,0,1,1,1),(31,'第六章 函数式编程',NULL,1517232797,1518360790,'# 高阶函数\r\n## 变量可以指向函数，函数名也是变量\r\n函数本身也可以赋值给变量，即：变量可以指向函数\r\n以下是函数的赋值：\r\n```\r\nIn [139]: s = \"abc\"\r\nIn [140]: ls = len(s)\r\nIn [141]: ls\r\nOut[141]: 3\r\nIn [142]: l = len\r\nIn [143]: l\r\nOut[143]: <function len>\r\nIn [144]: l(s)\r\nOut[144]: 3\r\n```\r\n因此：函数名是指向函数的变量，就表示是可以修改函数名的指向，如下：\r\n```\r\nIn [146]: len = 3\r\n\r\nIn [147]: len(s)\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-147-58f72b8c9eb5> in <module>()\r\n----> 1 len(s)\r\n\r\nTypeError: \'int\' object is not callable\r\n```\r\n如何解决以上问题呢？\r\n```\r\nIn [148]: del len\r\nIn [149]: len(s)\r\nOut[149]: 3\r\n```\r\n或者重启Python交互环境\r\n## 什么是高阶函数\r\n有了前面部分的铺垫，我们知道函数是指向变量的，并且函数的参数接收变量；因此就把函数做为参数传入的函数称为高阶函数。\r\n如下，把len函数做为参数传给func函数\r\n```\r\nIn [152]: def func(x, y, l):\r\n     ...:     return l(x) + l(y)\r\n     ...:\r\nIn [153]: func(\"abc\", \"123\", len)\r\nOut[153]: 6\r\n```\r\n## map/reduce\r\n### map\r\n```\r\nIn [158]: def func(x):\r\n     ...:     return x * x\r\n     ...:\r\n\r\nIn [159]: map(func, [1,2,3,4,5,6])\r\nOut[159]: [1, 4, 9, 16, 25, 36]\r\n```\r\n以上就是map的用法，map接收两个参数，第一个是函数，第二个是序列；作用就是迭代序列循环执行func函数。\r\n### reduce\r\nreduce函数必须接收两个参数，把结果继续和序列的下一个元素做函数计算\r\n```\r\n>>> def fn(x, y):\r\n...     return x * 10 + y\r\n...\r\n>>> reduce(fn, [1, 3, 5, 7, 9])\r\n13579\r\n```\r\n把str转换为int的函数：\r\n```\r\n>>> def fn(x, y):\r\n...     return x * 10 + y\r\n...\r\n>>> def char2num(s):\r\n...     return {\'0\': 0, \'1\': 1, \'2\': 2, \'3\': 3, \'4\': 4, \'5\': 5, \'6\': 6, \'7\': 7, \'8\': 8, \'9\': 9}[s]\r\n...\r\n>>> reduce(fn, map(char2num, \'13579\'))\r\n```\r\n或者\r\n```\r\ndef char2num(s):\r\n    return {\'0\': 0, \'1\': 1, \'2\': 2, \'3\': 3, \'4\': 4, \'5\': 5, \'6\': 6, \'7\': 7, \'8\': 8, \'9\': 9}[s]\r\n\r\ndef str2int(s):\r\n    return reduce(lambda x,y: x*10+y, map(char2num, s))\r\n```\r\n### map/reduce实践\r\n* 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[\'adam\', \'LISA\', \'barT\']，输出：[\'Adam\', \'Lisa\', \'Bart\']。\r\n* Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积。\r\n## filter\r\n和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。如下：\r\n```\r\nIn [223]: def f(x):\r\n     ...:     return x % 2 == 0\r\n     ...:\r\n\r\nIn [224]: filter(f, [x for x in xrange(1,11)])\r\nOut[224]: [2, 4, 6, 8, 10]\r\n```\r\n## sorted\r\n> 此函数让我真正了解到python的强大和简洁\r\n对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。\r\n```\r\nIn [230]: x = [11,23,99,37,87,88]\r\n\r\nIn [231]: sorted(x)\r\nOut[231]: [11, 23, 37, 87, 88, 99]\r\n# 实现倒序\r\nIn [232]: def reversed(x,y):\r\n     ...:     if x > y:\r\n     ...:         return -1\r\n     ...:     if x < y:\r\n     ...:         return 1\r\n     ...:     return 0\r\n     ...:\r\n\r\nIn [233]: sorted(x, reversed)\r\nOut[233]: [99, 88, 87, 37, 23, 11]\r\n\r\n# 还可以利用切片，切片就是构造一个与原序列相反的序列\r\nIn [239]: sorted(x)[::-1]\r\nOut[239]: [99, 88, 87, 37, 23, 11]\r\n# 还可以调用sorted的reverse参数\r\nIn [243]: sorted(x,reverse=True)\r\nOut[243]: [99, 88, 87, 37, 23, 11]\r\n```\r\n总之需要了解冒泡排序的算法。\r\n顺便这里复习一下切片：\r\n```\r\nprint str[0:3] #截取第一位到第三位的字符\r\nprint str[:] #截取字符串的全部字符\r\nprint str[6:] #截取第七个字符到结尾\r\nprint str[:-3] #截取从头开始到倒数第三个字符之前\r\nprint str[2] #截取第三个字符\r\nprint str[-1] #截取倒数第一个字符\r\nprint str[::-1] #创造一个与原字符串顺序相反的字符串\r\nprint str[-3:-1] #截取倒数第三位与倒数第一位之前的字符\r\nprint str[-3:] #截取倒数第三位到结尾\r\nprint str[:-5:-3] #逆序截取\r\n```\r\n# 返回函数\r\n顾名思义，将函数作为返回值返回。\r\n```\r\nIn [267]: def lazy_sum(*args):\r\n     ...:     def sum():\r\n     ...:         s = 0\r\n     ...:         for x in args:\r\n     ...:             s = s + x\r\n     ...:         return s\r\n     ...:     return sum\r\n     ...:\r\n\r\nIn [268]: f = lazy_sum(1,55,33,11)\r\n\r\nIn [269]: f\r\nOut[269]: <function __main__.sum>\r\n\r\nIn [270]: f()\r\nOut[270]: 100\r\n```\r\n在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\r\n从返回函数这里我们可以了解到：\r\n* 一个函数可以返回一个计算结果，也可以返回一个函数\r\n* 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量\r\n# 匿名函数\r\n```\r\nIn [25]: map(lambda x : x*x,[1,2,3,4,5,6,7,8])\r\nOut[25]: [1, 4, 9, 16, 25, 36, 49, 64]\r\n```\r\n`lambda`就是匿名函数的表达式，冒号前面的x表示函数参数，可以等同于：\r\n```\r\ndef f(x):\r\n    return x * x\r\n```\r\n特征：\r\n* 不用写`return`\r\n* 不用担心函数名重复\r\n# 装饰器\r\n```\r\n>>> def now():\r\n...     print(\'2015-3-25\')\r\n```\r\n假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）\r\n```\r\nIn [43]: def log(func):\r\n    ...:     def temp():\r\n    ...:         print(\'call %s():\' % func.__name__)\r\n    ...:         return func()\r\n    ...:     return temp\r\nIn [43]: @log\r\n    ...:     def now():\r\n    ...:         print(\'2015-3-25\')\r\n    ...:\r\nIn [44]: now()\r\ncall now():\r\n2015-3-25\r\n```\r\n`@log`相当于`now = log(now)`，此时可以使用decorator的高阶方式：\r\n```\r\nIn [56]: def log(text):\r\n    ...:     def d(func):\r\n    ...:         def temp():\r\n    ...:             print(\'%s,%s()\'%(text,func.__name__))\r\n    ...:             return func()\r\n    ...:         return temp\r\n    ...:     return d\r\n    ...:\r\n\r\nIn [57]: @log(\'haha\')\r\n    ...: def now():\r\n    ...:     print(\'2015-3-25\')\r\n    ...:\r\n\r\nIn [58]: now()\r\nhaha,now()\r\n2015-3-25\r\n```\r\n相当于`now = log(\'haha\')(now)`，但是经过了装饰器的函数__name__属性会发生变化：\r\n```\r\nIn [62]: now.__name__\r\nOut[62]: \'temp\'\r\n```\r\n可以通过`@functools.wraps(func)`来确保`__name__`属性不被修改：\r\n```\r\nimport functools\r\nIn [70]: def log(text):\r\n    ...:     def d(func):\r\n    ...:         @functools.wraps(func)\r\n    ...:         def temp():\r\n    ...:             print(\'%s,%s()\'%(text,func.__name__))\r\n    ...:             return func()\r\n    ...:         return temp\r\n    ...:     return d\r\n```\r\n# 偏函数\r\n使用`functools.partial`构造偏函数，作用就是把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单',1,'post','publish','Python','Python学习笔记',44,0,1,1,1),(32,'Java泛型',NULL,1517397571,1520927874,'# 泛型的由来\r\n为什么要有泛型，泛型的作用是什么，我想这是我们学习泛型最想得到的答案。\r\n先来看这样一段代码：\r\n```\r\nList<String> list = new ArrayList();\r\n```\r\n以上代码就是初始化一个集合，并且为这个集合指定了集合类型，即只能add一个String的元素。\r\n而在JDK1.5之前，我们是这样定义和使用的：\r\n```\r\nList list = new ArrayList();\r\nlist.add(1);\r\nlist.add(\"a\");\r\nlist.add(\'b\');\r\nInteger l1 = (Integer)list.get(0);\r\nString l2 = (String)list.get(1);\r\nchar l3 = (char)list.get(2);\r\n```\r\n获取集合元素时需要强转元素的类型，这样做的问题很大，如果强转类型与本身数据类型不匹配带来的问题是灾难性的。\r\n因此才推出了泛型，在定义集合时就确定集合元素的类型：\r\n```\r\nList<String> list = new ArrayList();\r\nlist.add(\"a\");\r\nString l1 = list.get(0);\r\n```\r\n如果还继续`list.add(1);`将会编译报错，因此这里**泛型的作用是在编译阶段就确定了集合的类型**，获取元素时就不用强转类型也就不会出现强转风险了。\r\n# 泛型的本质与作用域\r\n```\r\nArrayList<String> a = new ArrayList<>();\r\nArrayList<Integer> b = new ArrayList<>();\r\nClass c1 = a.getClass();\r\nClass c2 = b.getClass();\r\nSystem.out.println(c1 == c2);\r\n```\r\n结果为`true`。\r\n接着上面部分的代码，观察以下代码的输出：\r\n```\r\nSystem.out.println(c1);\r\nSystem.out.println(c2);\r\n```\r\n结果均为`class java.util.ArrayList`\r\n原因是它们的Class类型都是`ArrayList.class`，在运行阶段里是一致的。因此我们可以得出**泛型的作用域只在编译阶段**\r\n泛型应用的场景：泛型类、泛型方法、泛型集合\r\n# 泛型类\r\n```\r\npublic class JavaGenericity {\r\n    public static void main(String[] args) {\r\n        GenericClass<Integer> integerGenericClass = new GenericClass<>(100);\r\n        Integer g1 = integerGenericClass.getObject();\r\n        System.out.println(g1);\r\n        GenericClass<String> stringGenericClass = new GenericClass<>(\"abc\");\r\n        String g2 = stringGenericClass.getObject();\r\n        System.out.println(g2);\r\n    }\r\n}\r\n\r\nclass GenericClass<T> {\r\n    private T object;\r\n    public GenericClass(){}\r\n    public GenericClass(T object){\r\n        this.object = object;\r\n    }\r\n    public T getObject() {\r\n        return object;\r\n    }\r\n}\r\n```\r\n# 泛型方法\r\n```\r\npublic class JavaGenericity {\r\n    public static void main(String[] args) throws Exception {\r\n        JavaGenericity genericMethod = getObject(JavaGenericity.class);\r\n        System.out.println(\"Class:\" + genericMethod.getClass().getName());\r\n    }\r\n    public static <T> T getObject(Class<T> clz) throws InstantiationException, IllegalAccessException {\r\n        T t = clz.newInstance();\r\n        return t;\r\n    }\r\n}\r\n```\r\n# 泛型Map\r\n```\r\nclass GenericMap<K, V> {\r\n    private K key;\r\n    private V value;\r\n    public void put(K key, V value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n```\r\n# 泛型通配符\r\n```\r\nList<? extends Number> list = new ArrayList();\r\nList<? super Number> list = new ArrayList();\r\n```\r\n上面的 extends 和 super 关键字其实就是泛型的高级应用：泛型通配符。\r\n## 编译时类型和运行时类型\r\n```\r\nClass Fruit{}\r\nClass Apple extends Fruit{}\r\n```\r\n可以通过`Fruit apple = new Apple();`来申明对象apple，这也是多态的一种应用即向上转型。此时 apple 属性所指向的对象，其编译时类型和运行时类型是什么呢？\r\n**apple 属性所指向的对象，其在编译时的类型就是 Fruit 类型，而在运行时的类型就是 Apple 类型。**\r\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\r\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\r\n## 泛型中的向上转型\r\n```\r\npublic class Plate<T> {\r\n    private List<T> list;\r\n    public Plate(){} \r\n    public void add(T item){list.add(item);}\r\n    public T get(){return list.get(0);}\r\n}\r\nPlate<Fruit> plate = new Plate<Fruit>();\r\nplate.add(new Fruit());\r\nplate.add(new Apple());\r\n```\r\n而以下定义是错误的。\r\n`Plate<Fruit> plate = new Plate<Apple>();  //Error`\r\n**错误的原因：泛型并不直接支持向上转型，JVM 会要求其指向的对象是 Fruit 类型的对象。**\r\n只能通过通配符来实现：\r\n`Plate<? extends Fruit> plate = new Plate<Apple>();`\r\n## extends通配符\r\n定义：表示类型的上界，表示参数化类型的可能是T或是T的子类\r\n`Plate<? extends Fruit> list = new Plate<Apple>();`  这里因为编译器不知道list所持有的类型，所以无法安全的向其中添加对象，但是可以添加null,因为null 可以表示任何类型。\r\n只能通过现有类型以及子类型对其赋值。\r\n```\r\nFruit fruit = list.get(0);\r\nApple apple = (Apple)list.get(0);\r\n```\r\n也可以使用`contains`查看list是否包括某个元素\r\n## super通配符\r\n`Plate<? super Fruit> flist = new Plate<Apple>();`</br>\r\n定义：表示类型的下界，表示参数化类型是此类型的父类型直至Object</br>\r\n`List<? super Fruit> `表示“具有任何Fruit超类型的列表”，列表的类型至少是一个 Fruit 类型，因此可以安全的向其中添加Fruit 及其子类型。\r\n```\r\n// compile error:\r\nFruit item = flist.get(0);\r\n```\r\n因为，List<? super Fruit>中的类型可能是任何Fruit 的超类型，所以编译器无法确定get返回的对象类型是Fruit,还是Fruit的父类Food 或 Object.\r\n## 通配符总结\r\nextends 可用于的返回类型限定，不能用于参数类型限定。\r\nsuper 可用于参数类型限定，不能用于返回类型限定。\r\n\r\n\r\n\r\n\r\n\r\n\r\n',1,'post','publish','JAVA','Java基础',31,0,1,1,1),(33,'vim的应用',NULL,1517752247,1517822628,'# vi的一些设置 \r\nMac下新建文件~/.vimrc\r\n```\r\n# 显示行号\r\nse nu\r\n# tab的缩进改为2个空格\r\n:set tabstop=2\r\n:set shiftwidth=2\r\n:set expandtab\r\n```\r\n\r\n# 多行缩进缩出\r\n* 正常模式下，按两下>;光标所在行会缩进。\r\n* 如果先按了n，再按两下>;，光标以下的n行会缩进。\r\n* 对应的，按两下<;，光标所在行会缩出。\r\n* 如果在编辑代码文件，可以用=进行调整。\r\n* 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。\r\n* 或者n =，调整n行代码的缩排。\r\n\r\n转载自：http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html',1,'post','publish','Mac,vi','默认分类',9,0,1,1,1),(34,'1. 排序算法',NULL,1518354222,1518427193,'# 选择排序\r\n```\r\narr = [random.randint(100000,10000000) for x in range(10)]\r\nfor i in range(len(arr)):\r\n    min = i\r\n    for j in range(i+1,len(arr)):\r\n        if arr[j] < arr[min]:\r\n            min = j\r\n    arr[i],arr[min] = arr[min],arr[i]\r\nprint arr\r\n```',1,'post','publish','','算法',20,0,1,1,1),(35,'分布式redis',NULL,1518514856,1518514875,'# 检测baseimage-docker，以下命令可以检查镜像或下载\r\ndocker run --rm -t -i phusion/baseimage:0.10.0 /sbin/my_init -- bash -l\r\ndocker pull phusion/baseimage\r\n\r\ndocker run -d --name redis phusion/baseimage:0.10.0 /sbin/my_init --enable-insecure-key\r\n\r\ndocker inspect redis | grep IPA\r\n\"IPAddress\": \"172.17.0.4\"\r\n\r\ndocker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\r\n\r\n# 下载key\r\ncurl -o insecure_key -fSL https://github.com/phusion/baseimage-docker/raw/master/image/services/sshd/keys/insecure_key\r\nchmod 600 insecure_key\r\n\r\n# 登录容器\r\nssh -i insecure_key root@172.17.0.4\r\n\r\n# 在容器中执行命令\r\nssh -i insecure_key root@172.17.0.4 echo hello world',1,'post','publish','','redis',5,0,1,1,1),(36,'JSON对象处理',NULL,1520220915,1520220915,'一 加入依赖\r\n```\r\n<!-- json处理  -->\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>fastjson</artifactId>\r\n            <version>1.2.44</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>com.google.code.gson</groupId>\r\n            <artifactId>gson</artifactId>\r\n            <version>2.8.0</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>com.alibaba</groupId>\r\n                    <artifactId>fastjson</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>net.sf.json-lib</groupId>\r\n            <artifactId>json-lib</artifactId>\r\n            <version>2.4</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>com.alibaba</groupId>\r\n                    <artifactId>fastjson</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n```\r\n二 对象处理\r\n```\r\nJsonObject jsonObject = (JsonObject) parser.parse(new FileReader(filename1));\r\nString task_name = jsonObject.get(\"task\").getAsString();\r\n```',1,'post','publish','json','默认分类',11,0,1,1,1),(37,'Mybatis插入数据时返回自增主键',NULL,1520491749,1520491749,'# Mapper设计\r\n```\r\n<insert id=\"insertAndGetId\" useGeneratedKeys=\"true\" keyProperty=\"userId\" parameterType=\"com.User\">  \r\n    insert into user(userName,password)  \r\n    values(#{userName},#{password}})  \r\n</insert> \r\n```\r\n# 代码设计\r\n```\r\nSystem.out.println(\"插入前主键为：\"+user.getUserId());  \r\nuserDao.insertAndGetId(user);//插入操作  \r\nSystem.out.println(\"插入后主键为：\"+user.getUserId()); \r\n```\r\n插入前主键为：0  \r\n插入后主键为：1 ',1,'post','publish','','MyBatis',2,0,1,1,1),(38,'Java代码性能优化',NULL,1520823230,1520859551,'# 尽量指定类、方法的final修饰符\r\n为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。\r\n# 尽量重用对象\r\n例如使用StringBuilder、StringBuffer代替字符串连接。Java虚拟机生成对象和垃圾回收对象都是需要开销资源和时间，因此，生成过多的对象将会给程序的性能带来很大的影响。\r\n# 尽量使用局部变量\r\n调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束而结束，不需要额外的垃圾回收\r\n# 及时关闭流\r\n进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源\r\n# 减少对变量的重复计算\r\n`for (int i = 0; i < list.size(); i++) {...}`</br>\r\n换成</br>\r\n`for (int i = 0, int length = list.size(); i < length; i++) {...}`\r\n# 尽量采用懒加载的策略，即在需要的时候才创建\r\n`String str = \"s\"; if (i == 1) {list.add(str); }`</br>\r\n换成</br>\r\n`if (i == 1) {String str = \"s\"; list.add(str); }`\r\n# 不要在循环中使用try…catch…，应该把其放在最外层\r\n# 循环内尽量不要创建对象引用\r\n`for(...){List<String> list = new ArrayList<>(); list.add(...)}`</br>\r\n换成</br>\r\n`List<String> list = null;for(...){list = new ArrayList<>(); list.add(...)}`\r\n# 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList\r\n# 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而增加了性能开销\r\n# 尽量在合适的场合使用单例\r\n使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，单例主要适用于以下三个方面：\r\n* 控制资源的使用，通过线程同步来控制资源的并发访问\r\n* 控制实例的产生，以达到节约资源的目的\r\n* 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信\r\n\r\n# 尽量避免随意使用静态变量\r\n当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如:</br>\r\n`public class A { private static B b = new B(); }`</br>\r\n此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止\r\n\r\n# 使用同步代码块替代同步方法\r\n\r\n# 使用带缓冲的输入输出流进行IO操作\r\n带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，可以极大地提升IO效率\r\n\r\n# 顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList\r\n\r\n\r\n',1,'post','publish','Java','Java基础',39,0,1,1,1),(39,'Java反射',NULL,1520994592,1521006520,'# 为什么要有反射\r\n通常我们在创建对象时可以使用`new`关键字来实例化一个对象：\r\n```\r\nC c = new C();\r\n```\r\n但是当我们最开始并不知道要实例化的类对象是什么时，显然不能用`new`来实例化类对象了；因此这也是我们在一些框架中多次见到反射的原因，例如Spring在加载Bean时并不确定要加载多少Bean也不确定到底加载哪些Bean。而在我们寻常业务开发中实例化类对象时，类对象未知的情况并没有特别常见，因为可以直接使用确定的类对象创建，这也是很多初学者一直纠结反射到底有什么用的原因。但是反射的机制和原理，我们应该知道。\r\n# 获取类对象的方式\r\n## 使用类的class属性\r\n```\r\nClass c1 = C.class;\r\n```\r\n## 使用类对象的getClass()方法\r\n```\r\nC c = new C();\r\nClass c2 = c.getClass();\r\n```\r\n## 使用类路径的forName()方法\r\n可以看出上两种获取Class类对象的方式必须都要基于已确定的类，因此并不能解决不确定类实例化对象的情况，这时就需要使用类路径forName()方法：\r\n```\r\nClass cls = Class.forName(\"com.yaodao.domain.C\");\r\n```\r\n# 实例化对象\r\n## 通过 Class 对象的 newInstance() 方法\r\n```\r\nClass cls = Class.forName(\"com.yaodao.domain.C\");\r\nObject obj = cls.neInstance();\r\n```\r\n> 特点：实例化对象时，只能使用默认的无参构造方法\r\n## 通过 Constructor 对象的 newInstance() 方法\r\n```\r\nClass cls = Class.forName(\"com.yaodao.domain.C\");\r\nConstructor constructor = cls.getConstructor();\r\nObject obj = constructor.newInstance();\r\n```\r\n> 特点：实例化对象时，可以使用特定的构造方法，如：\r\n```\r\nConstructor constructor = cls.getConstructor(String.class);\r\n```\r\n# 获取类中的元素\r\n```\r\nclass C{\r\n    private int price;\r\n    public String name;\r\n    public C() {\r\n    }\r\n    public int getPrice() {\r\n        return price;\r\n    }\r\n    public void setPrice(int price) {\r\n        this.price = price;\r\n    }\r\n    private String getName(){\r\n        return name;\r\n    }\r\n}\r\n```\r\n## 通过反射获取类属性\r\n```\r\nField field1 = cls.getField(\"name\");\r\nField field2 = cls.getField(\"price\");\r\n```\r\n此时会出现一个异常`Exception in thread \"main\" java.lang.NoSuchFieldException: price`，原因就是price属性是私有属性，因此需要修改成以下方式获取：\r\n```\r\nField field2 = cls.getDeclaredField(\"price\");\r\n```\r\n## 通过反射获取方法\r\n```\r\ncls.getMethod(\"getPrice\");\r\ncls.getMethod(\"getName\");\r\n```\r\n此时也会出现一个异常`Exception in thread \"main\" java.lang.NoSuchMethodException: com.yaodao.domain.C.getName()`，同理也需要用到declared关键字\r\n## 通过反射获取构造器\r\n与获取方法和属性是类似的\r\n# 方法调用\r\n```\r\nClass cls = Class.forName(\"com.yaodao.domain.C\");\r\nConstructor constructor = cls.getConstructor();\r\nObject obj = constructor.newInstance();\r\n\r\nMethod method = cls.getMethod(\"setPrice\", int.class);\r\nmethod.invoke(obj, 55);\r\n\r\nmethod = cls.getMethod(\"getPrice\");\r\nString price = method.invoke(obj).toString();\r\nSystem.out.println(price);\r\n```\r\n这里可以看到具体的方法调用使用到了invoke()方法。\r\n## invoke()方法\r\ninvoke 方法内部有两种实现方式：\r\n* native 原生的实现方式\r\n* Java 实现方式\r\n\r\nNative 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过一定次数之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。这两种各有千秋，而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。\r\n\r\n参考：http://www.imooc.com/article/23418',1,'post','publish','Java反射','Java基础',30,0,1,1,1),(40,'第一章 工厂模式',NULL,1521017496,1521020274,'# 主要应用场景\r\n主要解决接口选择的问题。\r\n* 何时使用：需要不同条件下创建不同子类的实例时\r\n* 如何解决：在工厂接口中添加对产品子类的支持，返回的也是一个抽象的产品\r\n* 关键代码：工厂方法中根据不同条件，实例化不同的子类进行返回。\r\n# 简单实现\r\n```\r\npublic class TTest {\r\n    public static void main(String[] args) {\r\n        FruitFactory factory = new FruitFactory();\r\n        factory.getFruit(\"apple\").eat();\r\n        factory.getFruit(\"orange\").eat();\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * 抽象出一个类别\r\n */\r\nabstract class Fruit {\r\n    public abstract void eat();\r\n}\r\n\r\n/**\r\n * 具体的对象\r\n */\r\nclass Apple extends Fruit {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"eat apple\");\r\n    }\r\n}\r\n\r\n/**\r\n * 具体的对象\r\n */\r\nclass Orange extends Fruit {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"eat orange\");\r\n    }\r\n}\r\n\r\n/**\r\n * 根据不同类别提供不同对象\r\n */\r\nclass FruitFactory {\r\n    public Fruit getFruit(String type) {\r\n        if (\"orange\".equals(type)) {\r\n            return new Orange();\r\n        } else if (\"apple\".equals(type)) {\r\n            return new Apple();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n以上代码我们可以看出如果实际对象特别多，需要写太多的分支，因此需要对其改造。\r\n# 优雅实现\r\n不用构造分支区分不同对象，根据具体的类实例化对象，这里就需要应用反射了。\r\n```\r\npublic static void main(String[] args) {\r\n        FruitFactory factory2 = new FruitFactory();\r\n        try {\r\n            factory2.getFruit2(\"com.alibaba.cttp.Apple\").eat();\r\n            factory2.getFruit2(\"com.alibaba.cttp.Orange\").eat();\r\n        } catch (ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (InstantiationException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n/**\r\n * 根据不同类别提供不同对象\r\n */\r\nclass FruitFactory {\r\n    public Fruit getFruit2(String type) throws ClassNotFoundException, InstantiationException, IllegalAccessException{\r\n        Class cls = Class.forName(type);\r\n        return (Fruit)cls.newInstance();\r\n    }\r\n}\r\n```\r\n# 总结\r\n* 工厂模式可以解决接口选择问题，屏蔽细节，提供创建对象接口\r\n* 当有新增功能时，需要修改工厂类和实际对象',1,'post','publish','Java,设计模式','设计模式',4,0,1,1,1);
/*!40000 ALTER TABLE `t_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_logs`
--

DROP TABLE IF EXISTS `t_logs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_logs` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `action` varchar(100) DEFAULT NULL,
  `data` varchar(2000) DEFAULT NULL,
  `author_id` int(10) DEFAULT NULL,
  `ip` varchar(20) DEFAULT NULL,
  `created` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_logs`
--

LOCK TABLES `t_logs` WRITE;
/*!40000 ALTER TABLE `t_logs` DISABLE KEYS */;
INSERT INTO `t_logs` VALUES (1,'登录后台',NULL,1,'127.0.0.1',1515223439),(2,'保存系统设置','{\"social_zhihu\":\"\",\"social_github\":\"qcxiao\",\"social_twitter\":\"\",\"social_weibo\":\"\"}',1,'127.0.0.1',1515223831),(3,'保存系统设置','{\"social_zhihu\":\"\",\"social_github\":\"qcxiao\",\"social_twitter\":\"\",\"social_weibo\":\"\"}',1,'127.0.0.1',1515223877),(4,'保存系统设置','{\"site_record\":\"\",\"site_description\":\"估计要把此生浪费在永无止境的编程技术上了\",\"site_title\":\"幺刀的博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'127.0.0.1',1515224296),(5,'保存系统设置','{\"site_record\":\"\",\"site_description\":\"估计要把此生浪费在永无止境的编程技术上了\",\"site_title\":\"幺刀的博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'127.0.0.1',1515224312),(6,'系统备份',NULL,1,'127.0.0.1',1515224419),(7,'系统备份',NULL,1,'127.0.0.1',1515224466),(8,'登录后台',NULL,1,'127.0.0.1',1515225255),(9,'系统备份',NULL,1,'127.0.0.1',1515226124),(10,'系统备份',NULL,1,'127.0.0.1',1515226130),(11,'系统备份',NULL,1,'127.0.0.1',1515226149),(12,'系统备份',NULL,1,'127.0.0.1',1515226149),(13,'系统备份',NULL,1,'127.0.0.1',1515226150),(14,'系统备份',NULL,1,'127.0.0.1',1515226155),(15,'保存系统设置','{\"site_record\":\"\",\"site_description\":\"估计要把此生浪费在永无止境的编程技术上了\",\"site_title\":\"幺刀的博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'127.0.0.1',1515226205),(16,'登录后台',NULL,1,'127.0.0.1',1515227681),(17,'登录后台',NULL,1,'127.0.0.1',1515230222),(18,'登录后台',NULL,1,'127.0.0.1',1515233820),(19,'登录后台',NULL,1,'127.0.0.1',1515236269),(20,'登录后台',NULL,1,'127.0.0.1',1515238350),(21,'登录后台',NULL,1,'115.205.144.188',1515256444),(22,'修改密码',NULL,1,'115.205.144.188',1515256499),(23,'登录后台',NULL,1,'115.205.144.188',1515256522),(24,'删除文章','3',1,'115.205.144.188',1515256537),(25,'登录后台',NULL,1,'115.205.144.188',1515256705),(26,'删除文章','2',1,'115.205.144.188',1515258021),(27,'登录后台',NULL,1,'115.205.144.188',1515297983),(28,'登录后台',NULL,1,'115.205.144.188',1515303604),(29,'登录后台',NULL,1,'115.205.144.188',1515324464),(30,'登录后台',NULL,1,'115.205.144.188',1515332457),(31,'登录后台',NULL,1,'42.120.74.233',1515394991),(32,'登录后台',NULL,1,'42.120.74.233',1515417078),(33,'删除文章','/upload/2018/01/7e7aks6ki6hononi42buc6t759.jpg',1,'42.120.74.233',1515419640),(34,'删除文章','/upload/2018/01/sufmn8r3jqgbcq7qqg3l2840i9.png',1,'42.120.74.233',1515419666),(35,'登录后台',NULL,1,'42.120.74.233',1515460362),(36,'登录后台',NULL,1,'42.120.74.233',1515480043),(37,'登录后台',NULL,1,'42.120.74.233',1515499625),(38,'登录后台',NULL,1,'42.120.74.232',1515738574),(39,'删除文章','/upload/2018/01/05tbkr4ttkj22ol572r65li7t7.png',1,'42.120.74.226',1515916441),(40,'登录后台',NULL,1,'220.184.51.27',1515939224),(41,'删除文章','/upload/2018/01/tvu12ekl0gg9op31pvprvhrr4b.png',1,'42.120.74.250',1515997753),(42,'登录后台',NULL,1,'220.184.232.40',1516203288),(43,'修改个人信息','{\"uid\":1,\"email\":\"280887262@qq.com\",\"screenName\":\"admin\"}',1,'220.184.232.40',1516203326),(44,'登录后台',NULL,1,'42.120.74.235',1516863014),(45,'登录后台',NULL,1,'42.120.74.235',1516863032),(46,'登录后台',NULL,1,'42.120.74.235',1516863033),(47,'登录后台',NULL,1,'42.120.74.235',1516863034),(48,'登录后台',NULL,1,'42.120.74.235',1516863035),(49,'登录后台',NULL,1,'42.120.74.235',1516863039),(50,'登录后台',NULL,1,'42.120.74.235',1516863044),(51,'登录后台',NULL,1,'42.120.74.235',1516863059),(52,'登录后台',NULL,1,'42.120.74.235',1516863702),(53,'登录后台',NULL,1,'42.120.74.235',1516863712),(54,'删除文章','27',1,'42.120.74.235',1516864812),(55,'登录后台',NULL,1,'42.120.74.235',1516865559),(56,'登录后台',NULL,1,'115.193.41.8',1517059199),(57,'登录后台',NULL,1,'42.120.74.228',1517315191),(58,'登录后台',NULL,1,'115.193.41.195',1517749075),(59,'登录后台',NULL,1,'42.120.74.239',1518094425),(60,'登录后台',NULL,1,'42.120.74.245',1518347331),(61,'登录后台',NULL,1,'42.120.74.250',1520220699),(62,'登录后台',NULL,1,'42.120.74.226',1520491594),(63,'登录后台',NULL,1,'42.120.74.228',1520820970),(64,'登录后台',NULL,1,'42.120.74.248',1521004621),(65,'登录后台',NULL,1,'42.120.74.248',1521009748);
/*!40000 ALTER TABLE `t_logs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_metas`
--

DROP TABLE IF EXISTS `t_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  `sort` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=InnoDB AUTO_INCREMENT=54 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_metas`
--

LOCK TABLES `t_metas` WRITE;
/*!40000 ALTER TABLE `t_metas` DISABLE KEYS */;
INSERT INTO `t_metas` VALUES (6,'my github','https://github.com/qcxiao','link','',1,0),(8,'Java基础',NULL,'category',NULL,0,0),(9,'专栏','https://xiaozhuanlan.com/','link','',0,0),(10,'My-Blog','http://13blog.site/','link','',0,0),(11,'云收藏','http://favorites.ren/','link','',0,0),(12,'Java多线程',NULL,'category',NULL,0,0),(13,'Java','Java','tag',NULL,0,0),(14,'多线程','多线程','tag',NULL,0,0),(15,'Mysql',NULL,'category',NULL,0,0),(16,'Mysql','Mysql','tag',NULL,0,0),(17,'Docker','Docker','tag',NULL,0,0),(18,'默认分类','默认分类','category',NULL,0,0),(19,'Docker',NULL,'category',NULL,0,0),(20,'Python','Python','tag',NULL,0,0),(21,'Python',NULL,'category',NULL,0,0),(22,'自动化测试',NULL,'category',NULL,0,0),(23,'自动化测试','自动化测试','tag',NULL,0,0),(24,'git','git','tag',NULL,0,0),(25,'git',NULL,'category',NULL,0,0),(26,'Python学习笔记',NULL,'category',NULL,0,0),(27,'SpringBoot','SpringBoot','tag',NULL,0,0),(28,'SpringBoot',NULL,'category',NULL,0,0),(29,'Android',NULL,'category',NULL,0,0),(30,'Android','Android','tag',NULL,0,0),(31,'Anaconda','Anaconda','tag',NULL,0,0),(32,'Dockerfile','Dockerfile','tag',NULL,0,0),(33,'Spring',NULL,'category',NULL,0,0),(34,'Spring学习笔记',NULL,'category',NULL,0,0),(35,'Spring','Spring','tag',NULL,0,0),(36,'JavaWeb技术内幕',NULL,'category',NULL,0,0),(37,'JavaWeb','JavaWeb','tag',NULL,0,0),(38,'JDBC','JDBC','tag',NULL,0,0),(39,'MyBatis',NULL,'category',NULL,0,0),(40,'MyBatis','MyBatis','tag',NULL,0,0),(41,'RabbitMQ','RabbitMQ','tag',NULL,0,0),(42,'Python进阶',NULL,'category',NULL,0,0),(43,'积累','积累','tag',NULL,0,0),(44,'Linux基础探索系列',NULL,'category',NULL,0,0),(45,'Linux','Linux','tag',NULL,0,0),(46,'Mac','Mac','tag',NULL,0,0),(47,'vi','vi','tag',NULL,0,0),(48,'算法',NULL,'category',NULL,0,0),(49,'redis',NULL,'category',NULL,0,0),(50,'json','json','tag',NULL,0,0),(51,'Java反射','Java反射','tag',NULL,0,0),(52,'设计模式',NULL,'category',NULL,0,0),(53,'设计模式','设计模式','tag',NULL,0,0);
/*!40000 ALTER TABLE `t_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_options`
--

DROP TABLE IF EXISTS `t_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_options` (
  `name` varchar(32) NOT NULL DEFAULT '',
  `value` varchar(1000) DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_options`
--

LOCK TABLES `t_options` WRITE;
/*!40000 ALTER TABLE `t_options` DISABLE KEYS */;
INSERT INTO `t_options` VALUES ('allow_install','',NULL),('site_description','估计要把此生浪费在永无止境的编程技术上了',NULL),('site_keywords','13 Blog',NULL),('site_record','','备案号'),('site_theme','default',NULL),('site_title','幺刀的博客',''),('social_github','qcxiao',NULL),('social_twitter','',NULL),('social_weibo','',NULL),('social_zhihu','',NULL);
/*!40000 ALTER TABLE `t_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_relationships`
--

DROP TABLE IF EXISTS `t_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_relationships`
--

LOCK TABLES `t_relationships` WRITE;
/*!40000 ALTER TABLE `t_relationships` DISABLE KEYS */;
INSERT INTO `t_relationships` VALUES (4,12),(4,13),(4,14),(5,15),(5,16),(6,17),(6,19),(7,20),(7,21),(8,22),(8,23),(9,24),(9,25),(10,20),(10,26),(11,20),(11,26),(12,17),(12,27),(12,28),(13,29),(13,30),(14,20),(14,21),(14,31),(15,19),(15,32),(16,20),(16,26),(17,20),(17,26),(18,20),(18,26),(19,34),(19,35),(20,8),(20,13),(21,13),(21,36),(21,37),(22,8),(22,13),(22,16),(22,38),(23,27),(23,28),(23,39),(23,40),(24,27),(24,28),(24,41),(25,20),(25,42),(26,18),(26,43),(28,20),(28,21),(29,44),(29,45),(30,20),(30,26),(31,20),(31,26),(32,8),(32,13),(33,18),(33,46),(33,47),(34,48),(35,49),(36,18),(36,50),(37,39),(38,8),(38,13),(39,8),(39,51),(40,13),(40,52),(40,53);
/*!40000 ALTER TABLE `t_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_users`
--

DROP TABLE IF EXISTS `t_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `email` varchar(200) DEFAULT NULL,
  `home_url` varchar(200) DEFAULT NULL,
  `screen_name` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group_name` varchar(16) DEFAULT 'visitor',
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`username`),
  UNIQUE KEY `mail` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_users`
--

LOCK TABLES `t_users` WRITE;
/*!40000 ALTER TABLE `t_users` DISABLE KEYS */;
INSERT INTO `t_users` VALUES (1,'admin','a5b11783855873956214dc0d200b06dc','280887262@qq.com',NULL,'admin',1490756162,0,0,'visitor');
/*!40000 ALTER TABLE `t_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-03-19 16:27:41
